<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üêæ Neonpet Deluxe üêæ</title>
    <style>
        :root {
            --primary-gradient: linear-gradient(45deg, #ff00ff, #00ffff);
            --secondary-gradient: linear-gradient(45deg, #ff8a00, #e52e71);
            --neon-blue: #00ffff;
            --neon-pink: #ff00ff;
            --neon-yellow: #ffff00;
            --neon-green: #39ff14;
            --background-color: #1a0b2e;
            --overlay-color: rgba(0, 0, 0, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--background-color);
            color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            position: relative;
            overflow: hidden;
            min-height: 100vh;
        user-select: none;
        -webkit-user-select: none; /* Para Safari */
        -moz-user-select: none; /* Para Firefox */
        -ms-user-select: none; /* Para Internet Explorer y Edge */
        -o-user-select: none;
        }

        /* Overlay para atenuar la pantalla al morir */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-color);
            display: none;
            z-index: 15;
            transition: opacity 0.5s ease;
        }

        /* Clase para mostrar la overlay */
        .overlay.active {
            display: block;
            opacity: 1;
        }

        /* Clase para aplicar desenfoque cuando la luz est√° apagada */
        .blurred .game-container {
            filter: blur(5px);
            transition: filter 0.5s ease;
        }

        .frame {
            border: 2px solid var(--neon-blue);
            border-radius: 20px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 0 10px var(--neon-blue);
        }

.info-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  flex-wrap: nowrap;
  padding: 2px;
  background-color: #222;
}

.currency, .xp, .level, .weather {
  font-size: 0.5em;
  font-weight: bold;
  color: var(--neon-yellow);
  text-shadow: 0 0 5px var(--neon-yellow);
  margin: 0 2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: center;
  padding: 0;
}

.currency {
  width: 150px;
}

.xp {
  width: 120px;
}

.level {
  width: 100px;
}

.weather {
  width: 50px;
}

.xp span, .currency span, .level span {
  font-size: 0.5em;
}

        .status-bars {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .status-bar {
            width: 30%;
            min-width: 80px;
            text-align: center;
        }

        .bar-container {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin-bottom: 5px;
        }

        .status-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        #hunger-fill { background: var(--primary-gradient); }
        #fun-fill { background: var(--secondary-gradient); }
        #hygiene-fill { background: linear-gradient(45deg, #4facfe, #00f2fe); }

        .status-emoji {
            font-size: 1.5em;
        }

.display-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
}

.display-left {
    width: 75%; /* Aumentamos el tama√±o del display */
    border: 2px solid var(--neon-blue);
    border-radius: 10px;
    padding: 5px;
    height: 70px;
    overflow-y: auto;
}

.display-right {
    width: 20%; /* Reducimos el tama√±o del contenedor derecho (solo para la tienda) */
    display: flex;
    justify-content: center; /* Centramos el icono horizontalmente */
    align-items: center; /* Centramos el icono verticalmente */
    border: 2px solid var(--neon-blue); /* Marco solo para la tienda */
    border-radius: 10px; /* Bordes redondeados */
    padding: 5px;
    height: 70px; /* Aseguramos que tenga la misma altura que el display izquierdo */
}

.shop-icon {
    font-size: 2em; /* Tama√±o del icono */
    text-align: center;
}

.event-icon {
    font-size: 0.9em;
    margin-bottom: 5px;
    color: var(--neon-yellow);
    text-shadow: 0 0 5px var(--neon-yellow);
    opacity: 1;
    transition: opacity 0.5s ease;
}

/* Eliminamos el cofre */
.chest {
    display: none;
}

        .pet-frame {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            margin-bottom: 10px;
        }

        /* Clase para simetr√≠a en la cuadr√≠cula */
        .mini-game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 5px;
            width: 200px;
            height: 200px;
            margin: 20px auto;
        }

        .mini-game-cell {
            width: 100%;
            height: 100%;
            background-color: var(--neon-blue);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .mini-game-cell:active {
            transform: scale(0.95);
        }

        .pet-container {
            position: absolute;
            width: 30vh;
            height: 30vh;
            transition: transform 0.5s ease;
        }

.pet {
  font-size: 15vh;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  filter: drop-shadow(0 0 5px var(--neon-yellow));
  user-select: none;            /* Deshabilitar selecci√≥n en navegadores actuales */
  -webkit-user-select: none;     /* Deshabilitar selecci√≥n en Safari y Chrome */
  -moz-user-select: none;        /* Deshabilitar selecci√≥n en Firefox */
  -ms-user-select: none;         /* Deshabilitar selecci√≥n en Internet Explorer */
  -o-user-select: none;
  -webkit-touch-callout: none;   /* Prevenir men√∫ contextual en m√≥viles */
  touch-action: none;            /* Prevenir gestos que puedan interferir con toques */
  -webkit-tap-highlight-color: transparent;  /* Elimina el resalte azul en m√≥viles */
  transition: all 0.5s ease;
  cursor: pointer;
  z-index: 10;
}





        .pet-accessory {
            position: absolute;
            font-size: 10vh;
            z-index: 11;
            cursor: move;
            transition: all 0.5s ease;
        }

        .accessory-crown { top: -5vh; left: 50%; transform: translateX(-50%); }
        .accessory-glasses { top: 4vh; left: 50%; transform: translateX(-50%); font-size: 11vh; }
.accessory-hat {
    top: -3vh;
    left: 50%;
    transform: translateX(-50%);
    font-size: 6vh; /* Ajusta este valor para reducir el tama√±o */
}

.action-buttons {
    display: flex;
    justify-content: center;  /* Centramos los botones */
    align-items: center;
    padding: 10px;
    margin-bottom: 10px;
    flex-wrap: nowrap; /* Mantiene los botones en una sola l√≠nea */
    position: sticky;
    bottom: 0;
    background-color: var(--background-color);
    width: 100%;
    z-index: 10;  /* Asegura que los botones est√©n siempre visibles */
}

.action-buttons {
    display: flex;
    justify-content: center;  /* Centramos los botones */
    align-items: center;
    padding: 10px;
    margin-bottom: 20px; /* Aumentamos el margen inferior para alejarlos del borde */
    flex-wrap: nowrap; /* Mantiene los botones en una sola l√≠nea */
    position: sticky;
    bottom: 20px;  /* Ajustamos para que los botones est√©n un poco m√°s arriba */
    background-color: var(--background-color);
    width: 100%;
    z-index: 10;  /* Asegura que los botones est√©n siempre visibles */
}

.action-btn {
    font-size: 1.5em;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid var(--neon-blue);
    border-radius: 10px;
    padding: 10px;
    color: white;
    text-shadow: 0 0 5px var(--neon-blue);
    margin: 5px;
    flex: 1 1 auto;  /* Ajuste din√°mico de tama√±o */
    max-width: 80px;  /* Ajusta el ancho m√°ximo */
    text-align: center;
    cursor: pointer;
}

@media (max-width: 600px) {
    .action-btn {
        font-size: 1.2em;  /* Reduce el tama√±o de los botones en pantallas m√°s peque√±as */
        padding: 5px;      /* Ajuste del padding */
        flex: 1 1 60px;    /* Ajuste din√°mico de tama√±o en pantallas peque√±as */
        max-width: 60px;   /* Ancho m√°ximo ajustado para m√≥viles */
    }
    .action-buttons {
        justify-content: center;  /* Asegura que los botones tambi√©n se centren en pantallas peque√±as */
        bottom: 30px;  /* Ajusta el "bottom" en pantallas peque√±as para m√°s separaci√≥n */
    }
}


.follow-emoji {
    position: absolute;
    font-size: 2em;
    cursor: pointer;
    transition: transform 0.3s ease;
}
        .action-btn {
            font-size: 2em;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            padding: 10px;
            color: white;
            text-shadow: 0 0 5px var(--neon-blue);
            transition: transform 0.2s ease;
            margin: 5px;
            flex: 1 1 80px;
            max-width: 100px;
            text-align: center;
            cursor: pointer;
        }

        .action-btn:active {
            transform: scale(0.9);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 20;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.8);
        }

        .modal-content {
            background: var(--background-color);
            margin: 10% auto;
            padding: 20px;
            border: 2px solid var(--neon-blue);
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            border-radius: 20px;
            box-shadow: 0 0 15px var(--neon-blue);
            position: relative;
        }

        .close, .close-chest {
            color: var(--neon-pink);
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover, .close-chest:hover,
        .close:focus, .close-chest:focus {
            color: var(--neon-yellow);
            text-decoration: none;
        }

        .chest-modal {
            display: none;
            position: fixed;
            z-index: 20;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.7);
        }

        .chest-content {
            background-color: var(--background-color);
            margin: 15% auto;
            padding: 20px;
            border: 2px solid var(--neon-blue);
            width: 80%;
            max-width: 300px;
            border-radius: 10px;
            position: relative;
        }

        .chest-item {
            display: inline-block;
            font-size: 1.5em;
            margin: 5px;
            cursor: pointer;
        }

        .shop-items, .food-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .shop-item, .food-item {
            font-size: 1.2em;
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .shop-item:active, .food-item:active {
            transform: scale(0.95);
        }

        .chest, .shop-icon {
            font-size: 2em;
            cursor: pointer;
            margin: 0 15px;
        }

        .light-switch {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5em;
            cursor: pointer;
            z-index: 12;
        }

        .poop {
            position: absolute;
            font-size: 3em;
            cursor: pointer;
            z-index: 9;
        }

        .background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 1s ease;
            z-index: 5;
        }

        /* Nuevas clases para los fondos */
        .background1 {
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF); /* Azul cielo a azul claro */
        }

        .background2 {
            background: linear-gradient(to bottom, #FF7F50, #FFB6C1); /* Coral a rosa claro */
        }

        .background3 {
            background: linear-gradient(to bottom, #191970, #000000); /* Azul medianoche a negro */
        }

        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            z-index: 1;
        }

        .grid-cell {
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
        }
       .emoji-sick-green {
       filter: none;  /* Desactiva el brillo para mostrar el color verde natural */
       transition: filter 0.5s ease;
       }
       

        /* Estilos para bonus de caricia */
        .caress-bonus {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 20px;
            color: var(--neon-yellow);
            font-size: 1em;
            animation: fadeOut 3s forwards;
            z-index: 20;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }

        @media (max-width: 600px) {
            .currency, .xp, .weather {
                font-size: 1em;
            }
            .action-btn {
                font-size: 1.5em;
                padding: 8px;
                max-width: 80px;
            }
            .pet {
                font-size: 12vh;
            }
            .pet-container {
                width: 25vh;
                height: 25vh;
            }
            .event-icon {
                font-size: 0.8em;
            }
            .action-buttons {
                justify-content: center;
            }
            .action-btn {
                flex: 1 1 70px;
                margin: 5px;
            }
            .close, .close-chest {
                font-size: 1.2em;
            }
        }
    
#pet-container {
  position: relative;
}

#pet-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  background: transparent;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -o-user-select: none;
}
    
    
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Overlay para la muerte de la mascota -->
        <div class="overlay" id="deathOverlay"></div>

 <div class="frame info-bar">
 <div class="currency" id="currency">üí∞ 2000</div>
 <div class="xp" id="xp">‚≠ê 0</div>
 <div class="level" id="level">üî∫ Nivel 1</div>
 <div class="weather" id="weather">‚òÄÔ∏è</div>
 </div>
        <div class="frame status-bars">
            <div class="status-bar">
                <div class="bar-container"><div id="hunger-fill" class="status-fill"></div></div>
                <div class="status-emoji">üçî</div>
            </div>
            <div class="status-bar">
                <div class="bar-container"><div id="fun-fill" class="status-fill"></div></div>
                <div class="status-emoji">üéâ</div>
            </div>
            <div class="status-bar">
                <div class="bar-container"><div id="hygiene-fill" class="status-fill"></div></div>
                <div class="status-emoji">üöø</div>
            </div>
           
          
          
        </div>
        <div class="display-container">
            <div class="display-left" id="eventBar"></div>
            <div class="display-right">
                <div class="shop-icon" id="shopIcon">üè™</div>
                <div class="chest" id="chest">üì¶</div>
            </div>
        </div>
        <div class="frame pet-frame">
            <!-- Clase inicial para el fondo -->
            <div class="background background1" id="background"></div>
            <div class="grid-container" id="gridContainer"></div>
            <div class="pet-container">
                   <div id="pet-overlay"></div>
                <div class="pet" id="pet" draggable="true">üòä</div>
                <div id="crown" class="pet-accessory accessory-crown" draggable="true"></div>
                <div id="glasses" class="pet-accessory accessory-glasses" draggable="true"></div>
                <div id="hat" class="pet-accessory accessory-hat" draggable="true"></div>
            </div>
            <div class="light-switch" id="lightSwitch">üí°</div>
        </div>
       
      
      
<div class="action-buttons">
    <button class="action-btn" id="feed-btn">üçΩÔ∏è</button>
    <button class="action-btn" id="play-btn">üéÆ</button>
    <button class="action-btn" id="clean-btn">üßº</button>
    <!-- Bot√≥n para usar medicina, inicialmente oculto -->
    <button class="action-btn" id="use-medicine-btn" style="display: none;">üíä</button>
</div>

        <!-- Bonus por caricia -->
        <div class="caress-bonus" id="caressBonus" style="display: none;">
            üéâ ¬°Bonus por caricias activado! üéâ
        </div>
    </div>
<!-- Modal de Minijuego √önico -->
<div id="miniGameModal" class="modal">
    <div class="modal-content">
        <span class="close">‚ùå</span>
        <h2>üéÆ Minijuego</h2>
        <div id="mini-game-board" class="mini-game-board"></div>
        <!-- Contenedor para mensajes -->
        <div id="mini-game-message"></div>
    </div>
</div>
    <!-- Modales -->
    <div id="shopModal" class="modal">
        <div class="modal-content">
            <span class="close">‚ùå</span>
            <h2>üõçÔ∏è Tienda</h2>
            <div class="shop-items" id="shop-items"></div>
        </div>
    </div>
    
    <div id="foodModal" class="modal">
        <div class="modal-content">
            <span class="close">‚ùå</span>
            <h2>üçΩÔ∏è Comida</h2>
            <div class="food-items" id="food-items"></div>
        </div>
    </div>
    

    
    <div id="chestModal" class="chest-modal">
        <div class="chest-content">
            <span class="close-chest" id="closeChest">‚ùå</span>
            <h2>üì¶ Cofre</h2>
            <div id="chestItems"></div>
        </div>
    </div>
   
  
  
    <script>
// Variables globales
let petState = {
  hunger: 99,
  fun: 100,
  hygiene: 100,
  currency: 5000,
  xp: 0,
  level: 1,
  isSick: false,
  isDead: false,
  isPaused: false,
  caressCount: 0,
  shampooCount: 0,
  medicineCount: 0,
  accessories: {
    crown: '',
    glasses: '',
    hat: ''
  },
  expression: 'üòä',
  currentBackground: 1,
  achievements: {},
  startTime: null,
  weatherTimer: 0,
  weatherInterval: 60,
  lastExpressionChangeTime: 0,
  expressionChangeInterval: 2000, // Reducimos el intervalo para cambiar expresiones m√°s frecuentemente
  caressTimeout: null,
  poopsCleaned: 0 // A√±adido para el logro de limpieza
};

// Elementos del DOM
let pet, petContainer, crown, glasses, hat;
let hungerFill, funFill, hygieneFill, currencyElement;
let xpElement, levelElement, weatherElement, eventBar;
let lightSwitch, background, deathOverlay;
let useMedicineBtn; // Bot√≥n para usar medicina

// Botones de acci√≥n
let feedBtn, playBtn, cleanBtn, shopIcon;

// Modales
let shopModal, foodModal, miniGameModal;

// Constantes
const DECREASE_INTERVAL = 5000;
const HUNGER_DECREASE_RATE = 1;
const FUN_DECREASE_RATE = 0.8;
const HYGIENE_DECREASE_RATE = 0.7;
const SICKNESS_PROBABILITY = 0.01; // Incrementamos la probabilidad de enfermedad
const SPECIAL_EVENT_PROBABILITY = 0.05; // Incrementamos la probabilidad de eventos especiales

// Emojis para diferentes estados (a√±adidos m√°s emojis)
const lowStateEmojis = [
  'üò¢', 'üò≠', 'üòû', 'üòî', 'üôÅ', 'üòï', 'üòñ', 'üòü', 'üò£', 'üò©', 'üò´', 'ü•∫', 
  'üò•', 'üò∞', 'üò®', 'üòß', 'üòì', 'üò±', '‚òπÔ∏è', 'üò§', 'üòñ', 'üò∑', 'üòµ'
];

const mediumStateEmojis = [
  'üòê', 'üôÇ', 'üòå', 'üòë', 'üòí', 'üò∂', 'üòè', 'üò¨', 'üòó', 'ü§î', 'üòØ', 'üò¥', 
  'ü§®', 'üòë', 'üòï', 'üò¶', 'üòü', 'üò≥', 'üôÑ', 'üò¨', 'ü§•', 'ü§´',
];

const highStateEmojis = [
  'üòÑ', 'üòç', 'üòÅ', 'üòÉ', 'üòÄ', 'üòä', 'üòÜ', 'ü•∞', 'ü§©', 'üòé', 'üòö', 'üòô', 
  'üòú', 'ü§ó', 'üòù', 'üòá', 'ü§†', 'ü•≥', 'ü§™', 'üòã', 'ü§ì', 'üòπ'
];

const caressEmojis = [
  'üòä', 'üòå', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'ü•∞', 'üòá', 'ü§ó', 'üòò', 'üòª', 'üíñ'
];const weatherEmojis = ['‚òÄÔ∏è', 'üåßÔ∏è', '‚ùÑÔ∏è', 'üå§Ô∏è', 'üåà', '‚õàÔ∏è', 'üå™Ô∏è', 'üåô'];
let currentWeatherIndex = 0;

// Items
const shopItems = [
  { emoji: 'üëë', price: 500, type: 'crown', requiredLevel: 5 },
  { emoji: 'üëì', price: 300, type: 'glasses', requiredLevel: 3 },
  { emoji: 'üß¢', price: 200, type: 'hat', requiredLevel: 2 },
  { emoji: 'üß¥', price: 50, type: 'shampoo', requiredLevel: 1 },
  { emoji: 'üíä', price: 100, type: 'medicine', requiredLevel: 1 },
  { emoji: 'üé©', price: 1000, type: 'crown', requiredLevel: 10 },
  { emoji: 'ü•Ω', price: 800, type: 'glasses', requiredLevel: 8 },
  { emoji: 'üéì', price: 600, type: 'hat', requiredLevel: 7 }
];

const foodItems = [
  { emoji: 'üçé', hunger: 10, price: 50, requiredLevel: 1 },
  { emoji: 'üçî', hunger: 25, price: 100, requiredLevel: 2 },
  { emoji: 'üçï', hunger: 20, price: 150, requiredLevel: 3 },
  { emoji: 'üç¶', hunger: 5, price: 80, requiredLevel: 1 },
  { emoji: 'ü•ó', hunger: 15, price: 120, requiredLevel: 2 },
  { emoji: 'üç©', hunger: 8, price: 60, requiredLevel: 1 },
  { emoji: 'üç£', hunger: 22, price: 160, requiredLevel: 4 },
  { emoji: 'üçó', hunger: 28, price: 180, requiredLevel: 3 },
  { emoji: 'üç∞', hunger: 18, price: 140, requiredLevel: 2 },
  { emoji: 'üçõ', hunger: 30, price: 200, requiredLevel: 5 },
  { emoji: 'üçú', hunger: 20, price: 150, requiredLevel: 3 },
  { emoji: 'üå≠', hunger: 15, price: 100, requiredLevel: 2 }
];

// Frases variadas para la interfaz
const phrases = {
  feed: [
    "¬°Toma jeroma, pastillas de goma! üòã",
    "¬°Qu√© nivel, Maribel! üçΩÔ∏è",
    "¬°Esto es un fest√≠n, vaya vaya! ü§§",
    "¬°Qu√© me est√°s container, qu√© banquete! üç¥",
    "¬°Parece menterio de bueno! üòç",
    "¬°Me siento hacendado! ü•∞",
    "¬°Esto sabe a gloria bendita! üòä",
    "¬°Comida de cracks! üèÜ",
    "¬°Es verdura, tremendo plato! üçó",
    "¬°M√°s por favor, que esto est√° que te sales, minerales! üç∞"
  ],
  clean: [
    "¬°Echa el freno, Madaleno, qu√© limpio estoy! üõÅ",
    "¬°Me siento fresco como una lechuga! üå∏",
    "¬°A brillar, parece que estoy reci√©n encerado! ‚ú®",
    "¬°Ahora huelo mejor que las rosas de mi abuela! üå∫",
    "¬°Estoy listo para reventar la pista! üèÉ‚Äç‚ôÇÔ∏è",
    "¬°Reluciente, parece un espejo! üíé",
    "¬°Nada como estar limpio! üßΩ",
    "¬°Esto es vida, estar as√≠ de limpio! üòä",
    "¬°Adi√≥s mugre, te meo de Janeiro! üßº",
    "¬°Gracias por dejarme como nuevo! ‚ù§Ô∏è",
    "¬°Me has dejado como los chorros del oro! üöø"
  ],
  overfed: [
    "¬°Uf, com√≠ m√°s de la cuenta! ü§¢",
    "¬°Qu√© empacho, me da esgrima! üò£",
    "¬°Estoy como un barril, no puedo m√°s! üòì",
    "¬°Ay, qu√© dolor de tripa, qu√© risa, Mar√≠a Luisa! ü•¥",
    "¬°Necesito tumbarme, que esto no lo cura ni un milagro! üòÖ"
  ],
  sick: [
    "¬°Estoy m√°s pachucho que un guiri en agosto! ü§í",
    "¬°Aqu√≠ andamios, fatal de lo m√≠o! üò∑",
    "¬°Estoy de test√≠culo, qu√© baj√≥n! üòì",
    "¬°Me ha pegado un virus, esto es demigrante! ü§¢",
    "¬°Uf, necesito unas vacaciones! üèñÔ∏è"
  ],
  random: [
    "¬°Hoy es un d√≠a cualquiera... pero no para m√≠! üéâ",
    "¬°Qu√© d√≠a m√°s guapo, v√°monos de fiesta! üéä",
    "¬°Esto s√≠ que es vida, compa√±ero! üéà",
    "¬°A disfrutar, que la vida son dos d√≠as! üòé",
    "¬°Vamos a ver Chi-cago, que la cosa est√° buena hoy! üåû"
  ]
};

// Funci√≥n para obtener una frase aleatoria
function getRandomPhrase(category) {
  let phrasesArray = phrases[category];
  return phrasesArray[Math.floor(Math.random() * phrasesArray.length)];
}

// Funci√≥n para obtener una expresi√≥n aleatoria
function getRandomExpression(emojisArray) {
  return emojisArray[Math.floor(Math.random() * emojisArray.length)];
}

// Funci√≥n para desactivar la selecci√≥n de texto usando CSS y JavaScript
function disableTextSelection(element) {
  if (element) {
    element.style.userSelect = 'none';
    element.style.webkitUserSelect = 'none';
    element.style.msUserSelect = 'none';
    element.style.mozUserSelect = 'none';
    element.style.touchAction = 'none';
    element.style.webkitTouchCallout = 'none';
    element.onselectstart = () => false;
    element.onmousedown = () => false;
    element.onmousemove = () => false;
    element.onmouseup = () => false;
  }
}

// Funci√≥n para inicializar el juego
function initializeGame() {
  pet = document.getElementById('pet');
  petContainer = document.querySelector('.pet-container');
  crown = document.getElementById('crown');
  glasses = document.getElementById('glasses');
  hat = document.getElementById('hat');
  hungerFill = document.getElementById('hunger-fill');
  funFill = document.getElementById('fun-fill');
  hygieneFill = document.getElementById('hygiene-fill');
  currencyElement = document.getElementById('currency');
  xpElement = document.getElementById('xp');
  levelElement = document.getElementById('level');
  weatherElement = document.getElementById('weather');
  eventBar = document.getElementById('eventBar');
  lightSwitch = document.getElementById('lightSwitch');
  background = document.getElementById('background');
  deathOverlay = document.getElementById('deathOverlay');
  useMedicineBtn = document.getElementById('use-medicine-btn');

  feedBtn = document.getElementById('feed-btn');
  playBtn = document.getElementById('play-btn');
  cleanBtn = document.getElementById('clean-btn');
  shopIcon = document.getElementById('shopIcon');

  shopModal = document.getElementById('shopModal');
  foodModal = document.getElementById('foodModal');
  miniGameModal = document.getElementById('miniGameModal');

  // Agregar eventos a los botones de acci√≥n
  if (feedBtn) {
    feedBtn.addEventListener('click', () => {
      openModal(foodModal, updateFoodMenu);
    });
  }
  if (playBtn) {
    playBtn.addEventListener('click', () => {
      openModal(miniGameModal, startRandomMiniGame);
    });
  }
  if (cleanBtn) {
    cleanBtn.addEventListener('click', cleanPet);
  }
  if (shopIcon) {
    shopIcon.addEventListener('click', () => {
      openModal(shopModal, updateShopItems);
    });
  }

  // Evento para usar medicina
  if (useMedicineBtn) {
    useMedicineBtn.addEventListener('click', useMedicine);
  }

  // Agregar eventos a los botones de cierre de modales
  const closeButtons = document.querySelectorAll('.close');
  closeButtons.forEach(button => {
    button.addEventListener('click', () => {
      const modal = button.closest('.modal');
      if (modal) modal.style.display = 'none';
    });
  });

  // Cerrar modales al hacer clic fuera del contenido
  const modals = document.querySelectorAll('.modal');
  modals.forEach(modal => {
    modal.addEventListener('click', (event) => {
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    });
  });

  // Evento para el interruptor de luz (bot√≥n de pausa)
  if (lightSwitch) {
    lightSwitch.addEventListener('click', togglePause);
  }

  // Evento para acariciar a la mascota
if (petContainer) {
  petContainer.addEventListener('click', (e) => {
    e.stopPropagation();
    handleCaressBonus(e); // Pasar el evento 'e'
  });
}

  // Desactivar selecci√≥n de texto en la mascota y accesorios
  disableTextSelection(pet);
  disableTextSelection(crown);
  disableTextSelection(glasses);
  disableTextSelection(hat);
  disableTextSelection(petContainer);

  // Cargar el juego y comenzar el ciclo de juego
  loadGame();

  // Ejecutar el gameLoop cada segundo
  setInterval(gameLoop, 1000);

  // Iniciar la oscilaci√≥n del emoji
  startPetOscillation();

  // Redimensionar la mascota al cargar
  resizePet();
  window.addEventListener('resize', resizePet);

  // Actualizar la rejilla del fondo
  updateGrid();
}

// Funci√≥n para cargar el juego desde localStorage
function loadGame() {
  const savedState = localStorage.getItem('petState');
  if (savedState) {
    Object.assign(petState, JSON.parse(savedState));
    updateAccessoryDisplay('crown', petState.accessories.crown);
    updateAccessoryDisplay('glasses', petState.accessories.glasses);
    updateAccessoryDisplay('hat', petState.accessories.hat);
    updateStatus();
    updateExpression();
  }
}



// Funci√≥n para guardar el estado del juego en localStorage
function saveGame() {
  localStorage.setItem('petState', JSON.stringify(petState));
}

// Funci√≥n principal para el ciclo del juego
function gameLoop() {
  if (petState.isPaused || petState.isDead) {
    updateExpression();
    return;
  }

  // Disminuir gradualmente los niveles
  decreaseStats();

  // Cambiar el clima si es el momento adecuado
  changeWeather();

  // Redimensionar los accesorios si es necesario
  resizeAccessories();

  // Actualizar la expresi√≥n de la mascota
  updateExpression();

  // Generar eventos especiales con mayor frecuencia
  handleSpecialEvents();

  // Actualizar el estado visual del juego
  updateStatus();

  // Guardar el estado del juego
  saveGame();
}

// Funci√≥n para disminuir gradualmente los niveles de la mascota
function decreaseStats() {
  if (petState.isDead || petState.isPaused) return;

  // Disminuir los niveles, asegurando que no caigan por debajo de 0
  petState.hunger = Math.max(0, petState.hunger - HUNGER_DECREASE_RATE);
  console.log("Nivel de hambre actual: ", petState.hunger);  // Esto imprime el nivel de hambre en la consola
  petState.fun = Math.max(0, petState.fun - FUN_DECREASE_RATE);
  petState.hygiene = Math.max(0, petState.hygiene - HYGIENE_DECREASE_RATE);

  // Si el hambre llega a 0, la mascota muere
  if (petState.hunger <= 0) {
    petDeath();
    return;  // Termina la funci√≥n aqu√≠ si la mascota muere
  }

  // Si el hambre llega a 93, la mascota se empacha
  if (petState.hunger >= 97 && !petState.isSick) {  // Asegurarse de que no vuelva a empacharse
    petState.isSick = true;
    changeExpression('ü§¢');  // Cambiar la expresi√≥n a la cara de vomitar
    addEventToBar("¬°Cakiwaki est√° empachado! Espera a que su hambre baje.", "ü§¢");
  }

  // Si el hambre baja de 85 y estaba empachado, la mascota se recupera
  if (petState.hunger < 90 && petState.isSick) {
    petState.isSick = false;
    updateExpression();  // Cambiar la expresi√≥n a algo normal o feliz
    addEventToBar("üòä Cakiwaki se siente mejor. El empacho ha pasado.", "üòä");
  }

  // Posibilidad de que la mascota se enferme aleatoriamente
  randomSickness();
}

// Funci√≥n para manejar la enfermedad aleatoria
function randomSickness() {
  if (!petState.isSick && Math.random() < SICKNESS_PROBABILITY) {
    petState.isSick = true;
    changeExpression('ü§í');
    addEventToBar(getRandomPhrase('sick'), "Cakiwaki necesita medicina para recuperarse.");
  }
}

// Funci√≥n para manejar la muerte de la mascota
function petDeath() {
  petState.isDead = true;
  changeExpression('üíÄ');
  addEventToBar(getRandomPhrase('dead'), "Alimenta a Cakiwaki para revivirlo.");
  deathOverlay.style.display = 'block';

  // Abrir autom√°ticamente el men√∫ de comida para revivirlo
  openModal(foodModal, updateFoodMenu);

  saveGame();
}



// Funci√≥n para cambiar la expresi√≥n de la mascota
function changeExpression(newExpression) {
  if (pet) {
    pet.textContent = newExpression;
    petState.expression = newExpression;
    saveGame();
  }
}

function updateExpression() {
  const now = Date.now();

  // Array de emojis aleatorios para cuando la mascota est√° muerta
  const deadEmojis = ['üíÄ', 'üßü', 'üëª', 'üòà', 'ü•ë'];  // Calavera, zombie, fantasma, demonio y aguacate

  // Verificamos si ha pasado suficiente tiempo para cambiar la expresi√≥n
  if (now - petState.lastExpressionChangeTime > petState.expressionChangeInterval) {

    // Si la mascota est√° muerta
    if (petState.isDead) {
      // Selecciona aleatoriamente uno de los emojis del array deadEmojis
      const randomDeadEmoji = deadEmojis[Math.floor(Math.random() * deadEmojis.length)];
      changeExpression(randomDeadEmoji);  // Cambia la expresi√≥n a uno de los emojis aleatorios
      pet.style.filter = 'grayscale(100%)';  // Aplica el filtro de escala de grises

    // Si la mascota est√° empachada (prioridad m√°xima)
    } else if (petState.hunger >= 97) {
      changeExpression('ü§¢');  // Cara de empacho (verde)
      pet.style.filter = 'none';  // No aplicamos ning√∫n filtro para el empacho (cara verde)

    // Si el juego est√° pausado
    } else if (petState.isPaused) {
      changeExpression('üò¥');
      pet.style.filter = 'none';  // No aplicamos filtro cuando el juego est√° pausado

    // Si la mascota est√° enferma por enfermedad aleatoria (y no empachada)
    } else if (petState.isSick && petState.hunger < 92) {
      changeExpression('ü§í');  // Cara de fiebre (term√≥metro)
      pet.style.filter = 'hue-rotate(180deg)';  // Aplica el filtro de cambio de tono para la enfermedad

    // Si la mascota est√° siendo acariciada
    } else if (petState.caressing) {
      changeExpression(getRandomExpression(caressEmojis));  // Muestra una expresi√≥n feliz al acariciarlo
      pet.style.filter = 'none';  // Sin filtro para las caricias

    // Cambia la expresi√≥n seg√∫n el nivel de hambre
    } else {
      pet.style.filter = 'none';  // Restablecemos el filtro a ninguno

      // Nivel alto de hambre
      if (petState.hunger >= 50) {
        changeExpression(getRandomExpression(highStateEmojis));  // Expresiones para hambre alta

      // Nivel medio de hambre
      } else if (petState.hunger >= 30) {
        changeExpression(getRandomExpression(mediumStateEmojis));  // Expresiones para hambre media

      // Nivel bajo de hambre
      } else {
        changeExpression(getRandomExpression(lowStateEmojis));  // Expresiones para hambre baja
      }

      // Aplicamos el brillo solo en estados normales
      const brightness = 100 + (petState.fun / 2);
      pet.style.filter += ` brightness(${brightness}%)`;
    }

    // Actualizamos el tiempo de la √∫ltima vez que se cambi√≥ la expresi√≥n
    petState.lastExpressionChangeTime = now;
  }
}

function handleCaressBonus(event) {
  if (petState.isDead) return;

  petState.caressCount = (petState.caressCount || 0) + 1;
  petState.caressing = true;
  changeExpression(getRandomExpression(caressEmojis));

  // Verifica si el evento tiene coordenadas
  if (event && event.clientX && event.clientY) {
    const x = event.clientX;
    const y = event.clientY;
    console.log('Coordenadas del clic:', x, y); // A√±adir un log para verificar las coordenadas
    showTapEffect(x, y);
  }

  if (petState.caressCount % 3 === 0) {
    const funBonus = 10;
    petState.fun = Math.min(100, petState.fun + funBonus);
    addEventToBar(`üíñ ${getRandomPhrase('caressBonus')} +${funBonus}% diversi√≥n`);
    gainXP(2);
  }

  clearTimeout(petState.caressTimeout);
  petState.caressTimeout = setTimeout(() => {
    petState.caressing = false;
    updateExpression();
  }, 1000);

  updateStatus();
  saveGame();
}




function cleanPet() {
  if (petState.shampooCount > 0) {
    petState.hygiene = Math.min(100, petState.hygiene + 40);
    petState.shampooCount--;
    petState.currency += 10;
    addEventToBar(getRandomPhrase('clean'), "¬°Cakiwaki est√° limpio y feliz!");
    gainXP(5);
    updateStatus();
    saveGame();
  } else {
    addEventToBar("‚ùå No tienes shampoo", "Compra shampoo en la tienda para limpiar a Cakiwaki.");
  }
}

function addEventToBar(message, additionalInfo = "") {
const eventIcon = document.createElement('div');
eventIcon.classList.add('event-icon');
eventIcon.innerHTML = `${message}<br><small>${additionalInfo}</small>`;
eventIcon.style.fontSize = '0.8em';
eventBar.insertBefore(eventIcon, eventBar.firstChild);

while (eventBar.childNodes.length > 5) {
eventBar.removeChild(eventBar.lastChild);
}
}

function togglePause() {
  petState.isPaused = !petState.isPaused;
  if (petState.isPaused) {
    addEventToBar("üí§ Cakiwaki est√° durmiendo", "Los niveles se detienen.");
    changeExpression('üò¥');
  } else {
    addEventToBar("‚èØÔ∏è Cakiwaki ha despertado", "Las necesidades se reanudan.");
    updateExpression();
  }
  saveGame();
}

function openModal(modal, updateFunction) {
  modal.style.display = 'block';
  updateFunction();
}

function updateShopItems() {
  const shopItemsContainer = document.getElementById('shop-items');
  if (shopItemsContainer) {
    shopItemsContainer.innerHTML = '';
    shopItems.forEach(item => {
      const itemElement = createShopItem(item);
      shopItemsContainer.appendChild(itemElement);
    });
  }
}

function createShopItem(item) {
  const itemElement = document.createElement('div');
  itemElement.classList.add('shop-item');
  itemElement.innerHTML = `${item.emoji}<br>üí∞${item.price}<br>Nivel ${item.requiredLevel}`;

  if (petState.level >= item.requiredLevel) {
    if (['crown', 'glasses', 'hat'].includes(item.type)) {
      itemElement.onclick = () => toggleAccessoryButtons(item, itemElement);
    } else {
      itemElement.onclick = () => buyConsumableItem(item);
    }
  } else {
    itemElement.style.opacity = '0.5';
    itemElement.style.cursor = 'not-allowed';
  }

  return itemElement;
}

function toggleAccessoryButtons(item, itemElement) {
  if (itemElement.querySelector('.accessory-buttons')) return;

  const buttonsContainer = document.createElement('div');
  buttonsContainer.classList.add('accessory-buttons');

  const tickButton = document.createElement('button');
  tickButton.textContent = '‚úîÔ∏è';
  tickButton.classList.add('tick-button');
  tickButton.style.marginRight = '5px';
  tickButton.addEventListener('click', (e) => {
    e.stopPropagation();
    equipAccessory(item, itemElement);
  });

  const crossButton = document.createElement('button');
  crossButton.textContent = '‚ùå';
  crossButton.classList.add('cross-button');
  crossButton.addEventListener('click', (e) => {
    e.stopPropagation();
    unequipAccessory(item, itemElement);
  });

  buttonsContainer.appendChild(tickButton);
  buttonsContainer.appendChild(crossButton);
  itemElement.appendChild(buttonsContainer);
}

function equipAccessory(item, itemElement) {
  if (petState.currency < item.price || petState.level < item.requiredLevel) {
    addEventToBar("‚ùå No tienes suficientes recursos para equipar este accesorio.", "Aseg√∫rate de tener el nivel y monedas necesarios.");
    removeAccessoryButtons(itemElement);
    return;
  }

  petState.currency -= item.price;
  petState.accessories[getAccessoryType(item.type)] = item.emoji;
  updateAccessoryDisplay(getAccessoryType(item.type), item.emoji);
  addEventToBar(`üõçÔ∏è Compraste y equipaste: ${item.emoji}`, "¬°Cakiwaki luce genial con su nuevo accesorio!");
  gainXP(10);
  saveGame();
  removeAccessoryButtons(itemElement);
  shopModal.style.display = 'none';
}

function unequipAccessory(item, itemElement) {
  if (petState.accessories[getAccessoryType(item.type)] === item.emoji) {
    petState.accessories[getAccessoryType(item.type)] = '';
    updateAccessoryDisplay(getAccessoryType(item.type), '');
    addEventToBar(`‚ùå Has quitado: ${item.emoji}`, "El accesorio ha sido removido de Cakiwaki.");
    gainXP(5);
    saveGame();
  }
  removeAccessoryButtons(itemElement);
}

function updateAccessoryDisplay(type, emoji) {
  const accessoryElement = document.getElementById(type);
  if (accessoryElement) {
    accessoryElement.textContent = emoji;
  }
}

function removeAccessoryButtons(itemElement) {
  const buttonsContainer = itemElement.querySelector('.accessory-buttons');
  if (buttonsContainer) {
    buttonsContainer.remove();
  }
}

function getAccessoryType(type) {
  switch (type) {
    case 'crown':
    case 'topHat':
    case 'graduationCap':
      return 'crown';
    case 'glasses':
    case 'goggles':
      return 'glasses';
    case 'hat':
      return 'hat';
    default:
      return type;
  }
}

function buyConsumableItem(item) {
  if (petState.currency >= item.price && petState.level >= item.requiredLevel) {
    petState.currency -= item.price;
    switch(item.type) {
      case 'shampoo':
        petState.shampooCount++;
        addEventToBar(`üß¥ Has comprado shampoo`, "Ahora puedes limpiar a Cakiwaki.");
        break;
      case 'medicine':
        petState.medicineCount++;
        addEventToBar(`üíä Has comprado medicina`, "Util√≠zala cuando Cakiwaki est√© enfermo.");
        break;
    }
    gainXP(10);
    saveGame();
    shopModal.style.display = 'none';
  } else if (petState.level < item.requiredLevel) {
    addEventToBar(`‚ùå Necesitas nivel ${item.requiredLevel} para comprar esto.`, "Sigue cuidando a Cakiwaki para subir de nivel.");
  } else {
    addEventToBar("‚ùå No tienes suficientes monedas.", "Juega minijuegos o completa logros para ganar m√°s monedas.");
  }
}

function updateFoodMenu() {
  const foodItemsContainer = document.getElementById('food-items');
  foodItemsContainer.innerHTML = '';
  foodItems.forEach(item => {
    const itemElement = document.createElement('div');
    itemElement.classList.add('food-item');
    itemElement.innerHTML = `${item.emoji}<br>üí∞${item.price}<br>Nivel ${item.requiredLevel}`;
    

    if (petState.level >= item.requiredLevel && petState.currency >= item.price) {
      itemElement.onclick = () => feedPet(item);
    } else {
      itemElement.style.opacity = '0.5';
      itemElement.style.cursor = 'not-allowed';
    }

    foodItemsContainer.appendChild(itemElement);
  });
}

function feedPet(food) {
  if (petState.isDead) {
    revivePet();
    foodModal.style.display = 'none';
    return;
  }

  if (petState.currency >= food.price && petState.level >= food.requiredLevel) {
    petState.currency -= food.price;
    petState.hunger = Math.min(100, petState.hunger + food.hunger);
    addEventToBar(getRandomPhrase('feed'), `${food.emoji} ¬°Delicioso! Cakiwaki ha disfrutado su comida.`);
    gainXP(5);
    saveGame();
    foodModal.style.display = 'none';
  } else if (petState.level < food.requiredLevel) {
    addEventToBar(`‚ùå Necesitas nivel ${food.requiredLevel} para comprar esto.`, "Sigue cuidando a Cakiwaki para subir de nivel.");
  } else {
    addEventToBar("‚ùå No tienes suficientes monedas.", "Juega minijuegos o completa logros para ganar m√°s monedas.");
  }
}

function revivePet() {
  petState.isDead = false;
  petState.hunger = 50;
  petState.fun = 50;
  petState.hygiene = 50;
  changeExpression('üòä');
  addEventToBar("üéâ ¬°Cakiwaki ha revivido!", "Gracias por alimentarlo. Cu√≠dalo bien esta vez.");
  deathOverlay.style.display = 'none';
  saveGame();
}

function useMedicine() {
  if (petState.isSick && petState.medicineCount > 0) {
    petState.isSick = false;
    petState.medicineCount--;
    updateExpression();
    addEventToBar("üíä Cakiwaki se ha curado", "¬°Bien hecho! Cakiwaki se siente mucho mejor gracias a ti.");
    gainXP(5);
    updateStatus();
    saveGame();
  } else if (petState.medicineCount <= 0) {
    addEventToBar("‚ùå No tienes medicina.", "Compra medicina en la tienda para curar a Cakiwaki.");
  } else {
    addEventToBar("‚ÑπÔ∏è Cakiwaki no est√° enfermo.", "No necesitas usar medicina ahora.");
  }
}

function startRandomMiniGame() {
    const miniGames = [memoryGame, startFollowEmojiGame];
    const randomGame = miniGames[Math.floor(Math.random() * miniGames.length)];
    randomGame();
}

function startFollowEmojiGame() {
    const gameModal = document.getElementById('miniGameModal');
    const gameBoard = document.getElementById('mini-game-board');
    const messageContainer = document.getElementById('mini-game-message');
    const closeButton = document.querySelector('.close'); // Bot√≥n de cierre del modal
    
    // Configuraci√≥n del juego
    const GAME_DURATION = 10 * 1000; // Duraci√≥n de 10 segundos
    const EMOJI_INTERVAL = 200; // Intervalo r√°pido, emojis cada 200 ms
    const EMOJI_TYPES = ['üéà', 'üéâ', 'üí•', 'üí£', 'üéä', '‚ú®', 'üåü', 'üçÄ', 'üéÇ', 'üé∂', 'üç≠', 'üç¨'];
    let score = 0;
    let gameActive = false;
    let emojiCreationInterval;
    let gameTimer;
    let countdownInterval; // Intervalo para el contador de tiempo
    let timeLeft = 10; // Tiempo inicial de 10 segundos para el contador

    // PAUSAR el juego principal mientras se juega el minijuego
    petState.isPaused = true; // Esto detiene los descensos de niveles

    // Limpiar el tablero de juego
    gameBoard.innerHTML = '';
    messageContainer.innerHTML = `üéá<br>Puntos: <span id="emoji-count">${score}</span><br>time: <span id="countdown">${timeLeft}</span> segundos`;

    // Actualizar el contador de tiempo
    function updateCountdown() {
        timeLeft--;
        document.getElementById('countdown').textContent = timeLeft;
        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
        }
    }

    // Iniciar el juego
    gameActive = true;
    score = 0;
    timeLeft = 10; // Reinicia el tiempo

    // Crear y hacer caer un emoji
    function createFallingEmoji() {
        if (!gameActive) return;

        const emoji = document.createElement('div');
        emoji.classList.add('falling-emoji');
        emoji.textContent = EMOJI_TYPES[Math.floor(Math.random() * EMOJI_TYPES.length)];
        
        // Tama√±o aleatorio entre 30px y 60px
        const size = Math.floor(Math.random() * 30) + 30;
        emoji.style.width = `${size}px`;
        emoji.style.height = `${size}px`;
        emoji.style.fontSize = `${size}px`;
        
        // Posici√≥n aleatoria en el eje X
        const maxLeft = gameBoard.offsetWidth - size;
        const left = Math.floor(Math.random() * maxLeft);
        emoji.style.left = `${left}px`;
        emoji.style.top = `-100px`; // Empieza fuera de la pantalla

        gameBoard.appendChild(emoji);

        // Animaci√≥n de ca√≠da r√°pida
        const fallDuration = Math.floor(Math.random() * 2000) + 1000; // Duraci√≥n entre 1 y 3 segundos
        setTimeout(() => {
            emoji.style.transition = `top ${fallDuration}ms linear`;
            emoji.style.top = `${gameBoard.offsetHeight}px`;
        }, 50);

        // Remover el emoji si llega al fondo sin ser explotado
        emoji.addEventListener('transitionend', () => {
            if (emoji.parentElement === gameBoard) {
                emoji.remove();
            }
        });

        // Efecto al explotar el emoji
        emoji.addEventListener('click', () => {
            if (!gameActive) return;
            explodeEmoji(emoji);
        });
    }

    // Funci√≥n para explotar un emoji
    function explodeEmoji(emoji) {
        // Efecto visual de explosi√≥n
        emoji.classList.add('explode');
        // Incrementar el puntaje
        score++;
        // Actualizar el contador de emojis explotados
        document.getElementById('emoji-count').textContent = score;
        // Remover el emoji despu√©s de la animaci√≥n
        setTimeout(() => {
            if (emoji.parentElement === gameBoard) {
                emoji.remove();
            }
        }, 300); // Duraci√≥n de la explosi√≥n
    }

    // Funci√≥n para finalizar el juego
function endGame() {
    gameActive = false;
    clearInterval(emojiCreationInterval);
    clearTimeout(gameTimer);
    
    // Remover todos los emojis restantes
    const remainingEmojis = document.querySelectorAll('.falling-emoji');
    remainingEmojis.forEach(emoji => emoji.remove());

    // Mostrar el puntaje final (sin el texto extra)
    messageContainer.innerHTML = `‚è∞ ¬°Juego terminado!<br>Has explotado <strong>${score}</strong> emojis.`;

    // Recompensas seg√∫n el puntaje
    const coinsEarned = score * 10; // 10 monedas por cada emoji explotado
    const funEarned = Math.min(100, petState.fun + score * 0.5); // 0.5% diversi√≥n por emoji explotado

    // Actualizar el estado de la mascota
    petState.currency += coinsEarned;
    petState.fun = funEarned;
    addEventToBar(`üí∞ +${coinsEarned} monedas y üòä +${score * 0.5}% diversi√≥n por el minijuego.`);
    gainXP(score * 2); // 2 XP por cada emoji explotado

    // Reanudar el juego principal (los niveles vuelven a bajar)
    petState.isPaused = false; // Reanuda el juego principal

    // Actualizar la interfaz
    updateStatus();

    // Guardar el estado del juego
    saveGame();

    // Cerrar el modal del minijuego
    gameModal.style.display = 'none';

    // Si la mascota est√° muerta, permite revivirla toc√°ndola
    if (petState.isDead) {
        messageContainer.innerHTML += "<br>¬°Toca a Kakiwaki para revivirlo!";
        pet.addEventListener('click', function revivePet() {
            petState.hunger = 50;  // Revive con hambre al 50%
            petState.isDead = false;
            addEventToBar("¬°Kakiwaki ha revivido toc√°ndolo! üéâ");
            updateStatus();
            saveGame();
            pet.removeEventListener('click', revivePet);  // Remueve el evento despu√©s de revivir
        });
    }
}

    // Funci√≥n para cerrar el juego si el usuario cierra el modal
    function closeGame() {
        gameActive = false;
        clearInterval(emojiCreationInterval);
        clearInterval(countdownInterval); // Detenemos el contador de tiempo
        clearTimeout(gameTimer); 

        // Reanudar el juego principal (los niveles vuelven a bajar)
        petState.isPaused = false; // Reanuda el juego principal

        // Cerrar el modal del minijuego
        gameModal.style.display = 'none';
    }

    // Iniciar la creaci√≥n de emojis a intervalos regulares
    emojiCreationInterval = setInterval(createFallingEmoji, EMOJI_INTERVAL);

    // Iniciar el temporizador del juego
    gameTimer = setTimeout(endGame, GAME_DURATION);

    // Iniciar el contador de tiempo regresivo
    countdownInterval = setInterval(updateCountdown, 1000);

    // Evento para cerrar el juego si el usuario cierra el modal
    if (closeButton) {
        closeButton.addEventListener('click', closeGame);
    }
}

function memoryGame() {
    const gameBoard = document.getElementById('mini-game-board');
    const messageContainer = document.getElementById('mini-game-message');

    // Limpia el contenido del modal para empezar el nuevo minijuego
    gameBoard.innerHTML = ''; 
    messageContainer.innerHTML = 'Encuentra las parejas de emojis iguales';

    // Lista de emojis para el juego
    const emojiOptions = ['üòé', 'üòä', 'üòÇ', 'üòú', 'üòç', 'ü•≥', 'ü§î', 'üòá', 'ü§©', 'üò°'];
    
    // Duplicamos los emojis para formar las parejas
    let emojis = [...emojiOptions, ...emojiOptions];

    // Mezclamos los emojis de forma aleatoria
    emojis = emojis.sort(() => 0.5 - Math.random());

    // Variables del juego
    let firstSelection = null;
    let secondSelection = null;
    let matches = 0;
    const totalMatches = emojiOptions.length;

    // Funci√≥n para crear el tablero de memoria
    function createMemoryBoard() {
        emojis.forEach((emoji, index) => {
            const cell = document.createElement('div');
            cell.classList.add('mini-game-cell');
            cell.dataset.emoji = emoji;
            cell.dataset.index = index;
            cell.addEventListener('click', handleEmojiClick);
            gameBoard.appendChild(cell);
        });
    }

    // Funci√≥n que maneja el clic en un emoji
    function handleEmojiClick(e) {
        const clickedCell = e.target;

        // Evitar que el mismo emoji se seleccione dos veces
        if (clickedCell === firstSelection || clickedCell.classList.contains('matched')) {
            return;
        }

        clickedCell.textContent = clickedCell.dataset.emoji;

        if (!firstSelection) {
            // Primera selecci√≥n
            firstSelection = clickedCell;
        } else if (!secondSelection) {
            // Segunda selecci√≥n
            secondSelection = clickedCell;

            // Verificamos si coinciden
            if (firstSelection.dataset.emoji === secondSelection.dataset.emoji) {
                firstSelection.classList.add('matched');
                secondSelection.classList.add('matched');
                matches++;

                // Comprobamos si el jugador ha encontrado todas las parejas
                if (matches === totalMatches) {
                    messageContainer.innerHTML = '¬°Felicidades! Has encontrado todas las parejas üéâ';
                }

                // Reiniciamos la selecci√≥n
                firstSelection = null;
                secondSelection = null;
            } else {
                // Si no coinciden, volvemos a ocultar los emojis despu√©s de un peque√±o retraso
                setTimeout(() => {
                    firstSelection.textContent = '';
                    secondSelection.textContent = '';
                    firstSelection = null;
                    secondSelection = null;
                }, 1000);
            }
        }
    }

    // Iniciar el juego
    createMemoryBoard();
}

function gainXP(amount) {
  petState.xp += amount;
  if (petState.xp >= petState.level * 100) {
    levelUp();
  } else {
    addEventToBar(`‚≠ê +${amount} XP`, "¬°Sigue as√≠! Cada punto de experiencia te acerca al siguiente nivel.");
  }
  updateStatus();
}

function levelUp() {
  petState.level++;
  petState.xp = 0;
  addEventToBar(getRandomPhrase('levelUp'), "¬°Nuevas posibilidades para Cakiwaki!");
  petState.currency += petState.level * 50;
  updateStatus();
}

function handleSpecialEvents() {
  if (Math.random() < SPECIAL_EVENT_PROBABILITY && !petState.isDead && !petState.isPaused) {
    const randomEvent = getRandomPhrase('event');
    addEventToBar(randomEvent);
  }
}

function changeWeather() {
  petState.weatherTimer++;
  if (petState.weatherTimer >= petState.weatherInterval) {
    currentWeatherIndex = (currentWeatherIndex + 1) % weatherEmojis.length;
    weatherElement.textContent = weatherEmojis[currentWeatherIndex];
    petState.weatherTimer = 0;
  }
}

function updateGrid() {
  const gridContainer = document.getElementById('gridContainer');
  gridContainer.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const cell = document.createElement('div');
    cell.classList.add('grid-cell');
    gridContainer.appendChild(cell);
  }
}

const achievements = [
  { id: 'firstLevel', name: 'Primer Nivel', description: 'Alcanza el nivel 2', check: () => petState.level >= 2, reward: 100 },
  { id: 'petLover', name: 'Amante de Mascotas', description: 'Realiza 50 caricias', check: () => petState.caressCount >= 50, reward: 150 },
  { id: 'cleanFreak', name: 'Limpieza Total', description: 'Limpia 10 cacas', check: () => petState.poopsCleaned >= 10, reward: 100 },
  // ... otros logros
];

function checkAchievements() {
  achievements.forEach(achievement => {
    if (!petState.achievements) petState.achievements = {};
    if (!petState.achievements[achievement.id] && achievement.check()) {
      petState.achievements[achievement.id] = true;
      petState.currency += achievement.reward;
      addEventToBar(`üèÜ ¬°Logro desbloqueado: ${achievement.name}!`, `Recompensa: ${achievement.reward} monedas`);
      saveGame();
    }
  });
}

function createPoop() {
  if (Math.random() < 0.3 && !petState.isDead && !petState.isPaused) {
    const poops = document.querySelectorAll('.poop');
    if (poops.length >= 6) return;

    const poop = document.createElement('div');
    poop.classList.add('poop');
    poop.textContent = 'üí©';
    poop.style.left = `${Math.random() * 80 + 10}%`;
    poop.style.top = `${Math.random() * 80 + 10}%`;
    const size = Math.random() < 0.2 ? Math.random() * 40 + 60 : Math.random() * 20 + 20;
    poop.style.fontSize = `${size}px`;
    poop.style.zIndex = 11;

    poop.onclick = () => {
      poop.remove();
      petState.hygiene = Math.min(100, petState.hygiene + 5);
      petState.currency += 5;
      petState.poopsCleaned = (petState.poopsCleaned || 0) + 1;
      addEventToBar("üßπ Limpiaste una caca", "+5 monedas y +5% higiene");
      updateStatus();
      saveGame();
    };
    document.querySelector('.pet-frame').appendChild(poop);
  }
}

function updateStatus() {
  if (hungerFill) hungerFill.style.width = `${petState.hunger}%`;
  if (funFill) funFill.style.width = `${petState.fun}%`;
  if (hygieneFill) hygieneFill.style.width = `${petState.hygiene}%`;
  if (currencyElement) currencyElement.textContent = `üí∞ ${petState.currency}`;
  if (xpElement) xpElement.textContent = `‚≠ê ${petState.xp} / ${petState.level * 100}`;
  if (levelElement) levelElement.textContent = `üî∫ Nivel ${petState.level}`;

  if (petState.isSick && petState.medicineCount > 0) {
    useMedicineBtn.style.display = 'inline-block';
  } else {
    useMedicineBtn.style.display = 'none';
  }

  applyVisualEffects();
}



function showTapEffect(x, y, particleCount = 5, duration = 2000) {
  const emojis = ['üíñ', 'üåü', '‚ú®', '‚ù§Ô∏è', '‚≠ê']; // Emojis de part√≠culas
  
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    particle.style.position = 'absolute';
    particle.style.left = `${x}px`;
    particle.style.top = `${y}px`;
    particle.style.fontSize = '2.5em';
    particle.style.pointerEvents = 'none';
    particle.style.transition = `transform ${duration / 1000}s ease, opacity ${duration / 1000}s ease`;
    particle.style.zIndex = '9999'; // Aseg√∫rate de que las part√≠culas est√©n al frente

    // Agregar efecto de transformaci√≥n para movimiento
    const angle = Math.random() * 360; // √Ångulo aleatorio en grados
    const distance = Math.random() * 50 + 50; // Distancia aleatoria entre 50 y 100 p√≠xeles
    const transformX = Math.cos(angle) * distance;
    const transformY = Math.sin(angle) * distance;

    // A√±adir el particle al DOM
    document.body.appendChild(particle);

    // Aplicar la transformaci√≥n inicial
    setTimeout(() => {
      particle.style.transform = `translate(${transformX}px, ${transformY}px)`;
      particle.style.opacity = '0'; // Desvanecer las part√≠culas
    }, 50); // Peque√±a pausa antes de empezar la animaci√≥n

    // Eliminar la part√≠cula despu√©s de la duraci√≥n especificada
    setTimeout(() => {
      particle.remove();
    }, duration);
  }
}

function applyVisualEffects() {
  // Si la mascota est√° muerta, aplicamos filtro en escala de grises
  if (petState.isDead) {
    pet.style.filter = 'grayscale(100%)';
    changeExpression('üíÄ');  // Cara de muerto

  // Si est√° empachado (hambre >= 93), aplicamos la cara verde y bloqueamos cualquier otro cambio
  } else if (petState.hunger >= 93) {
    pet.style.filter = 'none';  // Desactivamos cualquier filtro (ni brillo ni hue-rotate)
    changeExpression('ü§¢');  // Cara de empacho (verde)
    
    // Nos aseguramos de que el estado de empacho tenga la m√°xima prioridad y no sea sobreescrito

  // Si est√° enferma por una enfermedad aleatoria (hambre < 93), aplicamos filtro de term√≥metro
  } else if (petState.isSick && petState.hunger < 93) {
    pet.style.filter = 'hue-rotate(180deg)';  // Cambia el tono para la enfermedad aleatoria
    changeExpression('ü§í');  // Cara de enfermo con term√≥metro

  // Caso normal (ni empachado, ni muerto, ni enfermo), aplica brillo seg√∫n la diversi√≥n
  } else {
    pet.style.filter = 'none';  // Restablecemos el filtro a ninguno
    updateExpression();  // Cambia la expresi√≥n dependiendo del nivel de hambre y diversi√≥n

    // Aplicamos el brillo solo en estados normales
    const brightness = 100 + (petState.fun / 2);
    pet.style.filter += ` brightness(${brightness}%)`;
  }

  // Redimensiona la mascota
  resizePet();
}

function resizePet() {
  const petFrame = document.querySelector('.pet-frame');
  const frameSize = Math.min(petFrame.offsetWidth, petFrame.offsetHeight);

  const hungerLevel = petState.hunger;
  const petSizeFactor = 0.1 + (hungerLevel / 170);  // Cambia el divisor para hacer crecer o reducir m√°s el emoji
  const petSize = frameSize * petSizeFactor;

  pet.style.fontSize = `${petSize}px`;
  resizeAccessories();
}

function resizeAccessories() {
  const petSize = pet.getBoundingClientRect();
  const scaleFactor = petSize.width / 100;

  if (crown) crown.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
  if (glasses) glasses.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
  if (hat) hat.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
}

function startPetOscillation() {
    let angle = 0;
    const baseAmplitude = 10;
    let amplitude = baseAmplitude;

    function oscillate() {
        if (!petState.isPaused && !petState.isDead) {
            if (petState.hunger > 80 && petState.fun > 80 && petState.hygiene > 80) {
                amplitude = 20;
                angle += 0.2;
            } else {
                amplitude = baseAmplitude;
                angle += 0.1;
            }

            // Calculamos el desplazamiento en X para la oscilaci√≥n
            const offsetX = amplitude * Math.sin(angle);
            pet.style.transform = `translate(-50%, -50%) translateX(${offsetX}px)`;

            // Obtener el tama√±o actual del emoji para usarlo en los accesorios
            const petSize = pet.getBoundingClientRect();
            const scaleFactor = petSize.width / 100; // Ajustar este valor para adaptar el tama√±o

            // Oscilar y redimensionar los accesorios
            const accessories = document.querySelectorAll('.pet-accessory');
            accessories.forEach(accessory => {
                // Ajustamos el tama√±o de los accesorios con el factor de escala
                accessory.style.transform = `translate(-50%, -50%) translateX(${offsetX}px) scale(${scaleFactor})`;
            });
        }
        requestAnimationFrame(oscillate);
    }
    oscillate();
}

setInterval(checkAchievements, 1000);
setInterval(createPoop, 5000);

window.onload = function() {
  initializeGame();
  resizePet();
  window.addEventListener('resize', resizePet);

  const pet = document.getElementById('pet');

  // Prevenir selecci√≥n de texto con selectstart
  pet.addEventListener('selectstart', (e) => {
    e.preventDefault();  // Evitar la selecci√≥n de texto
  });

  // Permitir los toques sin interferir
  pet.addEventListener('mousedown', (e) => {
    if (e.button === 0) {  // Solo prevenir la selecci√≥n en clic izquierdo (rat√≥n)
      e.preventDefault();  // Evita la selecci√≥n de texto pero permite el toque
    }
  });

  // Asegurar que no aparezca el men√∫ contextual en long tap o clic derecho
  pet.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  });
};


</script>

</body>
</html>
   
   

