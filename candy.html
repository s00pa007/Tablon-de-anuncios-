<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Match-3 Game</title>
    <style>
/* Tus estilos CSS aqu√≠ */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'Arial', sans-serif;
    overflow: hidden;
    background-color: #2c003e;
    padding: 20px 0;
}

.game-container {
    background-color: #4b0082;
    padding: 20px;
    border-radius: 15px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
    text-align: center;
    position: relative;
    width: 100%;
    max-width: 900px;
    transition: transform 0.3s;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
    height: auto;
}

.stats {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    width: 100%;
    margin-bottom: 20px;
}

.stats-left, .stats-right {
    display: flex;
    gap: 10px;
}

.stat {
    background-color: #1e90ff;
    padding: 10px 15px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 80px;
    white-space: nowrap;
}

.stats .stat.score {
    background-color: #ff8c00;
}

.stats .stat.target-score {
    background-color: #00ced1;
}

.stats .stat.high-score {
    background-color: #ff1493;
}

.stats .stat.level {
    background-color: #32cd32;
}

.stat-label {
    font-size: 0.7rem;
    color: #ffffff;
    text-shadow: 0 0 2px #000;
}

.stat-value {
    font-size: 1rem;
    font-weight: bold;
    color: #ffffff;
    text-shadow: 0 0 2px #000;
    max-width: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.controls {
    margin-top: 20px;
    display: flex;
    gap: 15px;
    justify-content: center;
}

.controls button {
    background-color: #ff5722;
    border: none;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.2rem;
    font-weight: bold;
    font-family: 'Arial', sans-serif;
    transition: background-color 0.3s, transform 0.2s;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
}

.controls button:hover {
    background-color: #e64a19;
    transform: translateY(-2px);
}

.grid {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 2px;
    justify-content: center;
    align-content: start;
    background-image: url('galaxy.png');
    background-size: cover;
    background-repeat: no-repeat;
    padding: 6px;
    border-radius: 10px;
    transition: all 0.3s ease-in-out;
    position: relative;
    overflow: hidden;
    width: 100%;
    max-width: 800px;
    aspect-ratio: 1 / 1;
    box-shadow: 0 4px 10px rgba(0,0,0,0.7);
    flex-grow: 1;
    margin: 0 auto;
}

.grid div {
    background-color: var(--bg-color, transparent);
    border: 2px solid #00838f;
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-size: 1.950rem;
    transition: transform 0.15s, box-shadow 0.15s, background-color 0.2s;
    position: relative;
    overflow: hidden;
    box-shadow: 0 3px 7px rgba(0,0,0,0.3);
    color: #fff;
    text-shadow: 0 0 2px #000;
    width: 100%;
    aspect-ratio: 1 / 1;
    padding: 2px;
    min-height: 0;
}

.grid div img[src="dog.png"] {
    width: 104.36%;
    height: 104.36%;
    object-fit: contain;
    margin: auto;
}

.grid div img:not([src="dog.png"]) {
    width: 94.875%;
    height: 94.875%;
    object-fit: contain;
    margin: auto;
}

.grid div:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(0, 131, 143, 0.8);
    background-color: var(--bg-color, rgba(178, 235, 242, 0.95));
}

.game-over {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 15rem;
    color: #d32f2f;
    text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
    z-index: 10;
    animation: shake 0.5s;
}

@keyframes shake {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    25% { transform: translate(-50%, -50%) rotate(5deg); }
    50% { transform: translate(-50%, -50%) rotate(-5deg); }
    75% { transform: translate(-50%, -50%) rotate(5deg); }
    100% { transform: translate(-50%, -50%) rotate(0deg); }
}

.match {
    animation: matchAnimation 0.2s forwards;
}

@keyframes matchAnimation {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.3);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 0;
    }
}

.score-popup {
    position: absolute;
    font-size: 0.96rem;
    background-color: rgba(0, 0, 0, 0.7);
    color: #ffeb3b;
    animation: popUp 0.68s forwards;
    pointer-events: none;
    font-weight: bold;
    text-shadow: 0 0 2px #000;
    z-index: 25;
    padding: 4px 8px;
    border-radius: 4px;
}

.score-popup.move-score {
    font-family: 'Arial', sans-serif;
    font-size: 1.35rem;
    font-weight: 900;
    text-align: center;
    animation: popUpScore 1s forwards;
    z-index: 2500;
    filter: drop-shadow(0 0 10px rgba(0,0,0,0.3));
}

.score-popup.move-score-green {
    color: #32CD32;
    background-color: rgba(0, 0, 0, 0.7);
    text-shadow: 0 0 2px #000;
}

.score-popup.move-score-purple {
    color: #9932CC;
    background-color: rgba(0, 0, 0, 0.7);
    text-shadow: 0 0 2px #000;
}

@keyframes popUpScore {
    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}

.particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
    border-radius: 15px;
    z-index: 2;
}

.particle {
    position: absolute;
    width: 6px;
    height: 6px;
    background: #ff4081;
    border-radius: 50%;
    opacity: 0;
    animation: particle 0.6s forwards;
    pointer-events: none;
}

@keyframes particle {
    from {
        opacity: 1;
        transform: translate(0, 0) scale(1);
    }
    to {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(1.5);
    }
}

.fall {
    animation: fallAnimation 0.6s ease-out forwards;
}

@keyframes fallAnimation {
    0% {
        transform: translateY(-100%);
    }
    100% {
        transform: translateY(0);
    }
}

.blinking {
    animation: blink 1s infinite;
    border: 3px solid gold;
    border-radius: 50%;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

.vibrate {
    animation: vibrate 0.5s;
}

@keyframes vibrate {
    0% { transform: translate(0); }
    20% { transform: translate(-2px, 2px); }
    40% { transform: translate(-2px, -2px); }
    60% { transform: translate(2px, 2px); }
    80% { transform: translate(2px, -2px); }
    100% { transform: translate(0); }
}

.hint {
    animation: hintAnimation 0.8s infinite;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px dashed #ffffff;
}

@keyframes hintAnimation {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

.level-up-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #00ff00, #007700);
    padding: 20px 40px;
    border-radius: 10px;
    font-size: 2.64rem;
    color: #00ff00;
    box-shadow: 0 0 20px rgba(0,255,0,0.7);
    animation: levelUpAnimation 1.5s forwards;
    z-index: 1000;
}

@keyframes levelUpAnimation {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

.info-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #ffffff;
    padding: 20px 30px;
    border-radius: 10px;
    font-family: 'Courier New', Courier, monospace;
    color: #000000;
    box-shadow: 0 0 20px rgba(0,255,0,0.7);
    z-index: 1001;
    max-width: 300px;
    width: 90%;
}

.info-popup h2 {
    font-size: 1rem;
    margin-bottom: 10px;
    text-align: center;
    color: #00ff00;
    text-shadow:
        0 0 6px #000,
        0 0 12px #00ff00,
        0 0 18px #00ff00,
        0 0 24px #00ff00;
}

.info-popup p {
    font-size: 0.6rem;
    line-height: 1.4;
    text-align: justify;
    color: #000000;
}

.info-popup button {
    background-color: #00ff00;
    border: none;
    color: #000;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.6rem;
    font-weight: bold;
    font-family: 'Courier New', Courier, monospace;
    margin-top: 10px;
    display: block;
    margin-left: auto;
    margin-right: auto;
    transition: background-color 0.3s, transform 0.2s;
}

.info-popup button:hover {
    background-color: #00cc00;
    transform: translateY(-1px);
}

@media (max-width: 800px) {
    .grid {
        width: 100%;
        height: 100%;
        padding: 4px;
        gap: 2px;
    }
}

@media (max-width: 600px) {
    .stats .stat-label, .stats .stat-value {
        font-size: 0.6rem;
    }
    .game-over {
        font-size: 1.05rem;
    }
    .score-popup {
        font-size: 0.48rem;
    }
    .controls button {
        padding: 6px 12px;
        font-size: 0.6rem;
    }
    .game-container {
        padding: 10px 0;
    }
    .controls {
        margin-top: 10px;
    }
    .grid {
        padding: 4px;
        gap: 1px;
    }
    .grid div {
        font-size: 2.1rem;
    }
    .stat-label, .stat-value {
        font-size: 1.0rem;
    }
    .combo-text {
        font-size: 1.68em;
        letter-spacing: -0.04em;
        text-shadow:
            0 0 6px #000,
            0 0 12px #ffff00,
            0 0 18px #ffff00,
            0 0 24px #ffff00;
    }
}

.combo-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2em;
    font-weight: 900;
    font-family: 'Arial', sans-serif;
    pointer-events: none;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    letter-spacing: -0.05em;
    color: #ffff00;
    text-shadow:
        0 0 6px #000,
        0 0 12px #ffff00,
        0 0 18px #ffff00,
        0 0 24px #ffff00;
}

.combo-text.show {
    opacity: 1;
    animation: fadeInOut 5s forwards; /* Ajusta el tiempo total aqu√≠ */
}

@keyframes fadeInOut {
    0% { opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }  /* Mantiene la visibilidad por m√°s tiempo */
    100% { opacity: 0; }
}

.play-total-score {
    position: absolute;
    font-size: 1.5rem;
    font-weight: bold;
    font-family: 'Arial', sans-serif;
    opacity: 0;
    transition: opacity 0.3s, transform 2.25s;
    pointer-events: none;
    z-index: 30;
    -webkit-text-stroke: 1px #FFFFFF; /* Perfil blanco */
    text-shadow: 
        0 0 5px #FFFFFF,
        0 0 10px #FFFFFF, 
        0 0 15px #FFFFFF, 
        0 0 20px #FFFFFF;
}

.play-total-score.green-score {
    color: #32CD32; /* Verde */
}

.play-total-score.purple-score {
    color: #9932CC; /* Morado */
}

.reaction-text {
    position: absolute;
    font-size: 1.6rem;
    font-weight: 900;
    font-family: 'Arial', sans-serif;
    pointer-events: none;
    z-index: 30;
    opacity: 0;
    transition: opacity 0.3s, transform 2.25s;
    -webkit-text-stroke: 1.5px #FFFFFF; /* Perfil blanco */
    text-shadow: 
        0 0 7px #FFFFFF,
        0 0 14px #FFFFFF,
        0 0 21px #FFFFFF,
        0 0 28px #FFFFFF,
        0 0 35px #FFFFFF;
}

.reaction-text.green-score {
    color: #32CD32; /* Verde */
}

.reaction-text.purple-score {
    color: #9932CC; /* Morado */
}

.play-total-score.show, .reaction-text.show {
    opacity: 1;
    animation: scaleUpFade 2.40s forwards;
}

@keyframes scaleUpFade {
    0% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.5); }
    100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
}



@keyframes reactionFade {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
    10% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    90% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}
    </style>
</head>
<body>

<div class="game-container">
    <div class="combo-text" id="combo-text">COMBO</div>
    
    <div class="stats">
        <div class="stats-left">
            <div class="stat score">
                <span class="stat-label">Score</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat target-score">
                <span class="stat-label">Next</span>
                <span class="stat-value" id="target-score">2000</span>
            </div>
        </div>
        <div class="stats-right">
            <div class="stat high-score">
                <span class="stat-label">Max Score</span>
                <span class="stat-value" id="high-score-value">0</span>
            </div>
            <div class="stat level">
                <span class="stat-label">Level</span>
                <span class="stat-value" id="level-indicator">1</span>
            </div>
        </div>
    </div>
    
    <div class="grid"></div>
    <div id="particles" class="particles"></div>
    <div id="game-over" class="game-over">üíÄ</div>
    <div class="controls">
        <button id="restart">üîÑ</button>
        <button id="info">‚ÑπÔ∏è</button>
    </div>

    <div class="play-total-score" id="play-total-score">0</div>
    <div class="reaction-text" id="reaction-text">Reacci√≥n</div>
</div>

<!-- Firebase Scripts -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<script>

const firebaseConfig = {
    apiKey: "AIzaSyBlIRJVI1buU48SPp0ErpCXhnuBdBEp8rk",
    authDomain: "tablon-de-anuncios-d5dea.firebaseapp.com",
    projectId: "tablon-de-anuncios-d5dea",
    storageBucket: "tablon-de-anuncios-d5dea.appspot.com",
    messagingSenderId: "67910184237",
    appId: "1:67910184237:web:e43d424657a948ae5d77a4",
    measurementId: "G-YL5W1VNM9Z"
};
        
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();




document.addEventListener('DOMContentLoaded', () => {
    const grid = document.querySelector('.grid');
    const width = 8;
    const allEmojis = ['üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','üòÇ','ü§£','üòä','üòá',
    'üôÇ','üôÉ','üòâ','üòå','üòç','ü•∞','üòò','üòó','üòô','üòö',
    'üòã','üòõ','üòù','üòú','ü§™','ü§®','üßê','ü§ì','üòé','ü•∏',
    'ü§©','ü•≥','üòè','üòí','üòû','üòî','üòü','üòï','üôÅ','‚òπÔ∏è',
    'üò£','üòñ','üò´','üò©','ü•∫','üò¢','üò≠','üò§','üò†','üò°',
    'ü§¨','üò≥','ü•µ','ü•∂','üò±','üò®','üò∞','üò•','üòì','ü§ó',
    'ü§î','ü§≠','ü§´','ü§•','üò∂','üòê','üòë','üò¨','üôÑ','üòØ',
    'üò¶','üòß','üòÆ','üò≤','ü•±','üò¥','ü§§','üò™','üòµ','ü§ê',
    'ü•¥','ü§¢','ü§Æ','ü§ß','üò∑','ü§í','ü§ï','ü§ë','ü§†','üòà',
    'üëø','üëπ','üë∫','ü§°','üí©','üëª','üíÄ','‚ò†Ô∏è','üëΩ','üëæ',
    'ü§ñ','üéÉ','üò∫','üò∏','üòπ','üòª','üòº','üòΩ','üôÄ','üòø',
    'üòæ',
    // Personas y profesiones
    'üßë','üë®','üë©','üë∂','üëß','üë¶','üë©‚Äçü¶∞','üë®‚Äçü¶∞','üë±‚Äç‚ôÄÔ∏è','üë±‚Äç‚ôÇÔ∏è',
    'üë©‚Äçü¶±','üë®‚Äçü¶±','üë©‚Äçü¶≥','üë®‚Äçü¶≥','üë©‚Äçü¶≤','üë®‚Äçü¶≤','üßì','üë¥','üëµ','üë≤',
    'üë≥‚Äç‚ôÄÔ∏è','üë≥‚Äç‚ôÇÔ∏è','üëÆ‚Äç‚ôÄÔ∏è','üëÆ‚Äç‚ôÇÔ∏è','üïµÔ∏è‚Äç‚ôÄÔ∏è','üïµÔ∏è‚Äç‚ôÇÔ∏è','üíÇ‚Äç‚ôÄÔ∏è','üíÇ‚Äç‚ôÇÔ∏è','üë∑‚Äç‚ôÄÔ∏è','üë∑‚Äç‚ôÇÔ∏è',
    'ü§¥','üë∏','üëº','ü§∞','ü§±','üë©‚Äç‚öïÔ∏è','üë®‚Äç‚öïÔ∏è','üë©‚Äçüéì','üë®‚Äçüéì','üë©‚Äçüè´',
    'üë®‚Äçüè´','üë©‚Äç‚öñÔ∏è','üë®‚Äç‚öñÔ∏è','üë©‚Äçüåæ','üë®‚Äçüåæ','üë©‚Äçüç≥','üë®‚Äçüç≥','üë©‚Äçüîß','üë®‚Äçüîß','üë©‚Äçüè≠',
    'üë®‚Äçüè≠','üë©‚Äçüíº','üë®‚Äçüíº','üë©‚Äçüî¨','üë®‚Äçüî¨','üë©‚Äçüíª','üë®‚Äçüíª','üë©‚Äçüé§','üë®‚Äçüé§','üë©‚Äçüé®',
    'üë®‚Äçüé®','üë©‚Äç‚úàÔ∏è','üë®‚Äç‚úàÔ∏è','üë©‚ÄçüöÄ','üë®‚ÄçüöÄ','üë©‚Äçüöí','üë®‚Äçüöí','üßë‚Äçüöí',
    // Animales y naturaleza
    'üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ',
    'ü¶Å','üêÆ','üê∑','üêΩ','üê∏','üêµ','üôà','üôâ','üôä','üêí',
    'üêî','üêß','üê¶','üê§','üê£','üê•','ü¶Ü','ü¶Ö','ü¶â','ü¶á',
    'üê∫','üêó','üê¥','ü¶Ñ','üêù','üêõ','ü¶ã','üêå','üêö','üêû',
    'üêú','üï∑Ô∏è','üï∏Ô∏è','ü¶Ç','üê¢','üêç','ü¶é','üêô','ü¶ë','ü¶ê',
    'ü¶Ä','üê°','üê†','üêü','üê¨','üê≥','üêã','ü¶à','üêä','üêÖ',
    'üêÜ','ü¶ì','ü¶ç','ü¶ß','üêò','ü¶è','üê™','üê´','ü¶í','üêÉ',
    'üêÇ','üêÑ','üêé','üêñ','üêè','üêë','üêê','ü¶å','üêï','üê©',
    'üêà','üêì','ü¶É','üïäÔ∏è','üêá','üêÅ','üêÄ','üêøÔ∏è','ü¶î',
    // Comida y bebidas
    'üçè','üçé','üçê','üçä','üçã','üçå','üçâ','üçá','üçì','ü´ê',
    'üçà','üçí','üçë','ü•≠','üçç','ü••','ü•ù','üçÖ','üçÜ','ü•ë',
    'ü•¶','ü•¨','ü•í','üå∂Ô∏è','ü´ë','üåΩ','ü•ï','ü´í','üßÑ','üßÖ',
    'üçÑ','ü•ú','üå∞','üçû','ü•ê','ü•ñ','ü•®','ü•Ø','ü•û','üßá',
    'üßÄ','üçñ','üçó','ü•©','ü•ì','üçî','üçü','üçï','üå≠','ü•™',
    'üåÆ','üåØ','ü•ô','üßÜ','ü•ö','üç≥','üßà','ü•ò','üç≤','ü•£',
    'ü•ó','üçø','üßÇ','ü•´','üç±','üçò','üçô','üçö','üçõ','üçú',
    'üçù','üç†','üç¢','üç£','üç§','üç•','ü•Æ','üç°','ü•ü','ü•†',
    'ü•°','ü¶™','üç¶','üçß','üç®','üç©','üç™','üéÇ','üç∞','üßÅ',
    'ü•ß','üç´','üç¨','üç≠','üçÆ','üçØ','üçº','ü•õ','‚òï','üçµ',
    'üç∂','üçæ','üç∑','üç∏','üçπ','ü•Ç','üç∫','üçª','ü•É','ü•§',
    'üßã','üßÉ','üßâ','üßä',
    // Actividades
    '‚öΩ','üèÄ','üèà','‚öæ','ü•é','üéæ','üèê','üèâ','üé±','üèì',
    'üè∏','ü•Ö','üèí','üèë','ü•ç','üèè','ü™Ä','ü•è','üéØ','ü™Å',
    'üé≥','üéÆ','üïπÔ∏è','üé∞','üé≤','‚ôüÔ∏è','üé≠','üé®','üé§','üéß',
    'üéº','üéπ','ü•Å','üé∑','üé∫','üé∏','ü™ï','üéª','ü™ó','üé¨',
    'üß©','üß∏',
    // Viajes y lugares
    'üöó','üöï','üöô','üöå','üöé','üèéÔ∏è','üöì','üöë','üöí','üöê',
    'üöö','üöõ','üöú','üõ¥','üö≤','üõµ','üèçÔ∏è','üõ∫','üö®','üöî',
    '‚úàÔ∏è','üõ©Ô∏è','üõ´','üõ¨','ü™Ç','üí∫','üöÅ','üõ∂','‚õµ','üö§',
    'üõ•Ô∏è','üö¢','‚öì','‚õ¥Ô∏è','ü™ù','üöß','üó∫Ô∏è','üß≠','üèûÔ∏è','üèïÔ∏è',
    'üèñÔ∏è','üèúÔ∏è','üèùÔ∏è','üèüÔ∏è','üèõÔ∏è','üèóÔ∏è','üß±','ü™®','ü™µ','ü™¥',
    'üåã','üóª','üèîÔ∏è','‚õ∞Ô∏è',
    // Objetos
    '‚åö','üì±','üì≤','üíª','‚å®Ô∏è','üñ•Ô∏è','üñ®Ô∏è','üñ±Ô∏è','üñ≤Ô∏è','üíΩ',
    'üíæ','üíø','üìÄ','üìº','üì∑','üì∏','üìπ','üé•','üìΩÔ∏è','üéûÔ∏è',
    'üìû','‚òéÔ∏è','üìü','üì†','üîã','üîå','üí°','üî¶','üïØÔ∏è','ü™î',
    'üßØ','üí∞','ü™ô','üí¥','üíµ','üí∂','üí∑','üí∏','üí≥','üßæ',
    'üíé','‚öñÔ∏è','üîß','üî®','‚öíÔ∏è','üõ†Ô∏è','‚õèÔ∏è','üî©','‚öôÔ∏è','üóúÔ∏è',
    '‚öóÔ∏è','üß™','üß´','üß¨','üî¨','üî≠','üì°','üíâ','ü©∏','üíä',
    'ü©π','ü©∫','üö™','üõèÔ∏è','üõãÔ∏è','ü™ë','üöΩ','üöø','üõÅ','ü™†',
    'üß¥','üß∑','üßπ','üß∫','üßª','ü™£','ü™§','üßº','ü™í','üßΩ',
    'üõí','üö¨','‚ö∞Ô∏è','‚ö±Ô∏è','üóø','ü™Ü','üõçÔ∏è','üß≥','üëì',
    'üï∂Ô∏è','ü•Ω','ü•º','ü¶∫','üëî','üëï','üëñ','üß£','üß§','üß•',
    'üß¶','üëó','üëò','üëô','üëö','üëõ','üëú','üëù','üéí','ü©¥',
    'üëû','üëü','ü•æ','ü•ø','üë†','üë°','ü©∞','üë¢','üëë','üëí',
    'üé©','üéì','üß¢','‚õëÔ∏è','üìø','üíÑ','üíç','üíé','üîá','üîà',
    'üîâ','üîä','üì¢','üì£','üìØ','üîî','üîï','üéº','üéµ','üé∂',
    'üèß','üöÆ','üö∞','‚ôø','üöπ','üö∫','üöª','üöº','üöæ','üõÇ',
    'üõÉ','üõÑ','üõÖ','‚ö†Ô∏è','üö∏','‚õî','üö´','üö≥','üö≠','‚ùå',
    '‚≠ï','‚úÖ','‚òëÔ∏è','‚úîÔ∏è','‚ùé','‚ûï','‚ûñ','‚ûó','‚úñÔ∏è','üí±',
    'üí≤','‚öïÔ∏è','‚ôªÔ∏è','üìõ','üî∞','üÜó','üÜô','üÜí','üÜï','üÜì',
    'üÜñ','üÖ∞Ô∏è','üÖ±Ô∏è','üÜé','üÜë','üÖæÔ∏è','üÜò','üõë','‚ÄºÔ∏è','‚ÅâÔ∏è',
    '‚ùì','‚ùî','‚ùï','‚ùó','üîÖ','üîÜ','üî±','‚öúÔ∏è',
    // Banderas
    'üè≥Ô∏è','üè¥','üèÅ','üö©','üè≥Ô∏è‚Äçüåà','üè≥Ô∏è‚Äç‚ößÔ∏è','üá¶üá´','üá¶üá±','üá©üáø','üá¶üá∏',
    'üá¶üá©','üá¶üá¥','üá¶üáÆ','üá¶üá∂','üá¶üá¨','üá¶üá∑','üá¶üá≤','üá¶üáº','üá¶üá∫','üá¶üáπ',
    'üá¶üáø','üáßüá∏','üáßüá≠','üáßüá©','üáßüáß','üáßüáæ','üáßüá™','üáßüáø','üáßüáØ','üáßüá≤',
    'üáßüáπ','üáßüá¥','üáßüá¶','üáßüáº','üáßüá∑','üáÆüá¥','üáªüá¨','üáßüá≥','üáßüá¨','üáßüá´',
    'üáßüáÆ','üá®üáª','üá∞üá≠','üá®üá≤','üá®üá¶','üáÆüá®','üá∞üáæ','üá®üá´','üáπüá©','üá®üá±',
    'üá®üá≥','üá®üáΩ','üá®üá®','üá®üá¥','üá∞üá≤','üá®üá¨','üá®üá©','üá®üá∞','üá®üá∑','üá®üáÆ',
    'üá≠üá∑','üá®üá∫','üá®üáæ','üá®üáø','üá©üá∞','üá©üáØ','üá©üá≤','üá©üá¥','üá™üá®','üá™üá¨',
    'üá∏üáª','üá¨üá∂','üá™üá∑','üá™üá™','üá™üáπ','üá´üáØ','üá´üáÆ','üá´üá∑','üá¨üá´','üáµüá´',
    'üáπüá´','üá¨üá¶','üá¨üá≤','üá¨üá™','üá©üá™','üá¨üá≠','üá¨üáÆ','üá¨üá∑','üá¨üá±','üá¨üá©',
    'üá¨üáµ','üá¨üá∫','üá¨üáπ','üá¨üá¨','üá¨üá≥','üá¨üáº','üá¨üáæ','üá≠üáπ','üá≠üá≥','üá≠üá∞',
    'üá≠üá∫','üáÆüá∏','üáÆüá≥','üáÆüá©','üáÆüá∑','üáÆüá∂','üáÆüá™','üáÆüá±','üáÆüáπ','üáØüá≤',
    'üáØüáµ','üáØüá™','üáØüá¥','üá∞üáø','üá∞üá™','üá∞üáÆ','üáΩüá∞','üá∞üáº','üá∞üá¨','üá±üá¶',
    'üá±üáª','üá±üáß','üá±üá∏','üá±üá∑','üá±üáæ','üá±üáÆ','üá±üáπ','üá±üá∫','üá≤üá¥','üá≤üá∞',
    'üá≤üá¨','üá≤üáº','üá≤üáæ','üá≤üáª','üá≤üá±','üá≤üáπ','üá≤üá≠','üá≤üá∂','üá≤üá∑','üá≤üá∫',
    'üáæüáπ','üá≤üáΩ','üá´üá≤','üá≤üá©','üá≤üá®','üá≤üá≥','üá≤üá™','üá≤üá∏','üá≤üá¶','üá≤üáø',
    'üá≤üá≤','üá≥üá¶','üá≥üá∑','üá≥üáµ','üá≥üá±','üá≥üá®','üá≥üáø','üá≥üáÆ','üá≥üá™','üá≥üá¨',
    'üá≥üá∫','üá≥üá´','üá∞üáµ','üá≥üá¥','üá¥üá≤','üáµüá∞','üáµüáº','üáµüá∏','üáµüá¶','üáµüá¨',
    'üáµüáæ','üáµüá™','üáµüá≠','üáµüá±','üáµüáπ','üáµüá∑','üá∂üá¶','üá∑üá¥','üá∑üá∫','üá∑üáº',
    'üáßüá±','üá∏üá≠','üá∞üá≥','üá±üá®','üáµüá≤','üáªüá®','üáºüá∏','üá∏üá≤','üá∏üáπ','üá∏üá¶',
    'üá∏üá≥','üá∑üá∏','üá∏üá®','üá∏üá±','üá∏üá¨','üá∏üá∞','üá∏üáÆ','üá∏üáß','üá∏üá¥','üáøüá¶',
    'üá∞üá∑','üá∏üá∏','üá™üá∏','üá±üá∞','üá∏üá©','üá∏üá∑','üá∏üáø','üá∏üá™','üá®üá≠','üá∏üáæ',
    'üáπüáº','üáπüáØ','üáπüáø','üáπüá≠','üáπüá±','üáπüá¨','üáπüá∞','üáπüá¥','üáπüáπ','üáπüá≥',
    'üáπüá∑','üáπüá≤','üáπüá®','üá∫üá¨','üá∫üá¶','üá¶üá™','üá¨üáß','üá∫üá∏','üá∫üáæ','üá∫üáø',
    'üáªüá∫','üáªüá¶','üáªüá™','üáªüá≥','üáºüá´','üá™üá≠','üáæüá™','üáøüá≤','üáøüáº',
    // Otros emojis populares
    'üéâ','üéä','üéà','üéÇ','üç∞','üç¶','üç©','üç™','üç´','üç¨',
    'üç≠','üçÆ','üéÅ','üéÄ','üéóÔ∏è','üéüÔ∏è','üé´','üéñÔ∏è','üèÜ','ü•á',
    'ü•à','ü•â','‚öΩÔ∏è','üèÄ','üèà','‚öæÔ∏è','üéæ','üèê','üèâ','üé±',
    'üèì','üè∏','ü•Ö','üèí','üèë','ü•ç','üèè','ü™Ä','ü•è','üéØ',
    'ü™Å','üé≥','üéÆ','üïπÔ∏è','üé∞','üé≤','‚ôüÔ∏è','üé≠','üé®','üé§',
    'üéß','üéº','üéπ','ü•Å','üé∑','üé∫','üé∏','ü™ï','üéª','ü™ó',
    'üé¨','üß©','üß∏',
    ];
    const bombEmoji = 'üí£';
    const dogEmoji = 'üê∂';
    let emojis = [];
    const squares = [];
    let score = 0;
    let level = 1;
    let highScore = 0;
    let destroyedEmojis = {};
    let totalGamesPlayed = 0;
    let totalTimePlayed = 0;
    let gameStartTime;
    let powerUpActive = false;
    let blinkingIndex = null;
    let currentEmojis = [];
    let powerUpRange = 1;
    let previousEmojis = [];
    let isLevelUpInProgress = false;
    let emojisDestroyedSinceLastBomb = 0;
    let comboMultiplier = 1;
    let playTotalScore = 0;
    let lastMatchIndex = null;
    let matchCountThisMove = 0;
    let hintInterval;
    let hintTimeout;
    let targetScore = 1200;
    const gameOverDisplay = document.getElementById('game-over');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level-indicator');
    const highScoreDisplay = document.getElementById('high-score-value');
    const targetScoreDisplay = document.getElementById('target-score');
    const restartButton = document.getElementById('restart');
    const infoButton = document.getElementById('info');
    const particlesContainer = document.getElementById('particles');
    const gameContainer = document.querySelector('.game-container');
    const comboDisplay = document.getElementById('combo-text');
    const playTotalScoreDisplay = document.getElementById('play-total-score');
    const reactionTextDisplay = document.getElementById('reaction-text');
    let dragStartIndex;
    let dragEndIndex;
    let touchStartX = null;
    let touchStartY = null;
    let touchStartIdLocal = null;
    let emojiColors = {};
    function assignColorsToEmojis() {
        const colors = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'];
        let colorIndex = 0;
        allEmojis.forEach(emoji => {
            emojiColors[emoji] = colors[colorIndex % colors.length];
            colorIndex++;
        });
        emojiColors[bombEmoji] = '#000';
        emojiColors[dogEmoji] = '#ff9900';
    }
    assignColorsToEmojis();
    const softColors = ['#FFEBEE', '#F3E5F5', '#E3F2FD', '#E8F5E9', '#FFF3E0'];
    function getTargetScore(level) {
        if (level === 1) return 600;
        return 400 * level;
    }
    function initializeGame() {
        const randomColor = softColors[Math.floor(Math.random() * softColors.length)];
        grid.style.backgroundColor = randomColor;
        loadHighScore();
        loadStatistics();
        if (!loadGameState()) {
            setCurrentEmojis();
            createBoard();
            gameStartTime = Date.now();
            targetScore = getTargetScore(level);
            updateTargetScore();
            stabilizeBoard();
            playTotalScore = 0;
            updatePlayTotalScoreDisplay();
            resetIdleTimer();
        }
    }
    function loadHighScore() {
        const storedHighScore = localStorage.getItem('highScore');
        if (storedHighScore) {
            highScore = parseInt(storedHighScore);
            highScoreDisplay.textContent = highScore;
        }
    }
    function updateHighScore() {
        if (score > highScore) {
            highScore = score;
            highScoreDisplay.textContent = highScore;
            localStorage.setItem('highScore', highScore);
        }
    }
    function loadStatistics() {
        const storedGamesPlayed = localStorage.getItem('gamesPlayed');
        if (storedGamesPlayed) {
            totalGamesPlayed = parseInt(storedGamesPlayed);
        }
        const storedTimePlayed = localStorage.getItem('timePlayed');
        if (storedTimePlayed) {
            totalTimePlayed = parseInt(storedTimePlayed);
        }
        const storedDestroyedEmojis = localStorage.getItem('destroyedEmojis');
        if (storedDestroyedEmojis) {
            destroyedEmojis = JSON.parse(storedDestroyedEmojis);
        } else {
            destroyedEmojis = {};
        }
    }
    function saveStatistics() {
        localStorage.setItem('gamesPlayed', totalGamesPlayed);
        localStorage.setItem('timePlayed', totalTimePlayed);
        localStorage.setItem('destroyedEmojis', JSON.stringify(destroyedEmojis));
    }
    function setCurrentEmojis() {
        if (level === 1) {
            currentEmojis = [dogEmoji];
            const initialEmojis = getRandomUniqueEmojis(allEmojis, 3);
            currentEmojis = currentEmojis.concat(initialEmojis);
        } else {
            const newEmoji = getNewEmoji();
            if (newEmoji) {
                currentEmojis.push(newEmoji);
            }
        }
    }
    function addNewEmojiForLevel() {
        const newEmoji = getNewEmoji();
        if (newEmoji && !currentEmojis.includes(newEmoji)) {
            currentEmojis.push(newEmoji);
        }
    }
    async function fillEmptySpaces() {
        return new Promise(resolve => {
            for (let col = 0; col < width; col++) {
                let emptySpots = 0;
                for (let row = width - 1; row >= 0; row--) {
                    const idx = row * width + col;
                    if (emojis[idx] === '' || emojis[idx] === undefined) {
                        emptySpots++;
                    } else if (emptySpots > 0) {
                        const newIdx = (row + emptySpots) * width + col;
                        const movingEmoji = emojis[idx];
                        emojis[newIdx] = movingEmoji;
                        setSquareContent(squares[newIdx], movingEmoji);
                        squares[newIdx].style.setProperty('--bg-color', emojiColors[movingEmoji]);
                        emojis[idx] = '';
                        clearSquareContent(squares[idx]);
                        squares[newIdx].classList.add('fall');
                        setTimeout(() => {
                            squares[newIdx].classList.remove('fall');
                        }, 600);
                    }
                }
                for (let row = 0; row < emptySpots; row++) {
                    const idx = row * width + col;
                    if (currentEmojis.length - 1 < level) {
                        addNewEmojiForLevel();
                    }
                    const newEmoji = getRandomEmoji();
                    if (newEmoji) {
                        emojis[idx] = newEmoji;
                        setSquareContent(squares[idx], newEmoji);
                        squares[idx].style.setProperty('--bg-color', emojiColors[newEmoji]);
                        squares[idx].classList.add('fall');
                        setTimeout(() => {
                            squares[idx].classList.remove('fall');
                        }, 600);
                    }
                }
            }
            setTimeout(() => {
                updatePowerUpPosition();
                resolve();
            }, 600);
        });
    }
    function getRandomUniqueEmojis(array, number) {
        const filteredArray = array.filter(emoji =>
            emoji !== bombEmoji &&
            emoji !== dogEmoji &&
            !previousEmojis.includes(emoji) &&
            !currentEmojis.includes(emoji)
        );
        for (let i = filteredArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [filteredArray[i], filteredArray[j]] = [filteredArray[j], filteredArray[i]];
        }
        return filteredArray.slice(0, number);
    }
    function getNewEmoji() {
        const availableEmojis = allEmojis.filter(emoji =>
            !currentEmojis.includes(emoji) &&
            emoji !== bombEmoji &&
            emoji !== dogEmoji &&
            !previousEmojis.includes(emoji)
        );
        if (availableEmojis.length === 0) return null;
        const randomIndex = Math.floor(Math.random() * availableEmojis.length);
        return availableEmojis[randomIndex];
    }
    function createBoard() {
        grid.innerHTML = '';
        emojis = [];
        squares.length = 0;
        for (let i = 0; i < width * width; i++) {
            const square = document.createElement('div');
            square.setAttribute('draggable', true);
            square.setAttribute('id', i);
            grid.appendChild(square);
            squares.push(square);
        }
        fillBoard();
        addEventListeners();
    }
    function fillBoard() {
        for (let i = 0; i < squares.length; i++) {
            if (emojis[i] === undefined || emojis[i] === '') {
                let randomEmoji = getRandomEmoji();
                if (randomEmoji) {
                    emojis[i] = randomEmoji;
                    setSquareContent(squares[i], randomEmoji);
                    squares[i].style.setProperty('--bg-color', emojiColors[randomEmoji]);
                }
            }
        }
    }
    function stabilizeBoard() {
        let matches = findAllMatches();
        while (matches.length > 0) {
            matches.forEach(match => {
                match.forEach(index => {
                    let newEmoji = getRandomEmoji();
                    if (newEmoji) {
                        emojis[index] = newEmoji;
                        setSquareContent(squares[index], newEmoji);
                        squares[index].style.setProperty('--bg-color', emojiColors[newEmoji]);
                    }
                });
            });
            matches = findAllMatches();
        }
    }
    function getRandomEmoji() {
        const rand = Math.floor(Math.random() * currentEmojis.length);
        return currentEmojis[rand];
    }
    function setSquareContent(square, emoji) {
        if (emoji === dogEmoji) {
            square.innerHTML = '<img src="dog.png" alt="Dog" class="dog-image">';
        } else {
            square.innerHTML = '';
            square.textContent = emoji;
            square.style.color = emoji !== bombEmoji ? '#FFD700' : '#FFFFFF';
            square.style.textShadow = '0 0 2px #000';
        }
    }
    function clearSquareContent(square) {
        square.innerHTML = '';
        square.textContent = '';
        square.style.setProperty('--bg-color', 'transparent');
    }
    function addEventListeners() {
        squares.forEach(square => {
            square.addEventListener('dragstart', dragStart);
            square.addEventListener('dragover', dragOver);
            square.addEventListener('drop', dragDrop);
            square.addEventListener('dragend', dragEnd);
            square.addEventListener('click', handleSquareClick);
        });
        squares.forEach(square => {
            square.addEventListener('touchstart', handleTouchStart, { passive: true });
            square.addEventListener('touchend', handleTouchEnd, { passive: true });
        });
        restartButton.addEventListener('click', resetGame);
        infoButton.addEventListener('click', showInfo);
        document.addEventListener('mousedown', resetIdleTimer);
        document.addEventListener('touchstart', resetIdleTimer);
    }
    function dragStart(e) {
        dragStartIndex = parseInt(this.id);
        this.classList.add('dragging');
    }
    function dragOver(e) {
        e.preventDefault();
    }
    function dragDrop(e) {
        dragEndIndex = parseInt(this.id);
        if (isAdjacent(dragStartIndex, dragEndIndex)) {
            swapEmojis(dragStartIndex, dragEndIndex);
            const initialMatches = findMatchesUserAction();
            if (initialMatches.length > 0) {
                resetIdleTimer();
                checkMatches(true);
            } else {
                swapEmojis(dragEndIndex, dragStartIndex);
            }
        }
    }
    function dragEnd() {
        squares.forEach(square => square.classList.remove('dragging'));
    }
    function handleTouchStart(e) {
        if (e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchStartIdLocal = parseInt(this.id);
        }
    }
    function handleTouchEnd(e) {
        if (touchStartX === null || touchStartY === null) return;
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const threshold = 30;
        let dragEndIndexLocal = touchStartIdLocal;
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > threshold) {
                dragEndIndexLocal = touchStartIdLocal + 1;
            } else if (deltaX < -threshold) {
                dragEndIndexLocal = touchStartIdLocal - 1;
            }
        } else {
            if (deltaY > threshold) {
                dragEndIndexLocal = touchStartIdLocal + width;
            } else if (deltaY < -threshold) {
                dragEndIndexLocal = touchStartIdLocal - width;
            }
        }
        if (isAdjacent(touchStartIdLocal, dragEndIndexLocal) && dragEndIndexLocal >= 0 && dragEndIndexLocal < width * width) {
            swapEmojis(touchStartIdLocal, dragEndIndexLocal);
            const initialMatches = findMatchesUserAction();
            if (initialMatches.length > 0) {
                resetIdleTimer();
                checkMatches(true);
            } else {
                swapEmojis(dragEndIndexLocal, touchStartIdLocal);
            }
        }
        touchStartX = null;
        touchStartY = null;
        touchStartIdLocal = null;
    }
    function handleSquareClick(e) {
        const index = parseInt(this.id);
        if (powerUpActive && index === blinkingIndex && emojis[index] === bombEmoji) {
            triggerPowerUp(index);
            resetIdleTimer();
        }
    }
    function isAdjacent(index1, index2) {
        const row1 = Math.floor(index1 / width);
        const col1 = index1 % width;
        const row2 = Math.floor(index2 / width);
        const col2 = index2 % width;
        const rowDiff = Math.abs(row1 - row2);
        const colDiff = Math.abs(col1 - col2);
        return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
    }
    function swapEmojis(index1, index2) {
        const tempEmoji = emojis[index1];
        emojis[index1] = emojis[index2];
        emojis[index2] = tempEmoji;
        setSquareContent(squares[index1], emojis[index1]);
        setSquareContent(squares[index2], emojis[index2]);
        squares[index1].style.setProperty('--bg-color', emojiColors[emojis[index1]]);
        squares[index2].style.setProperty('--bg-color', emojiColors[emojis[index2]]);
        updatePowerUpPosition();
        saveGameState();
    }
    function updatePowerUpPosition() {
        if (powerUpActive) {
            const newBlinkingIndex = emojis.findIndex(emoji => emoji === bombEmoji);
            if (newBlinkingIndex !== -1) {
                if (blinkingIndex !== null && blinkingIndex !== newBlinkingIndex) {
                    squares[blinkingIndex].classList.remove('blinking');
                }
                blinkingIndex = newBlinkingIndex;
                squares[blinkingIndex].classList.add('blinking');
            } else {
                if (blinkingIndex !== null) {
                    squares[blinkingIndex].classList.remove('blinking');
                }
                blinkingIndex = null;
                powerUpActive = false;
            }
        }
    }
    function findAllMatches() {
        const matches = [];
        for (let row = 0; row < width; row++) {
            for (let col = 0; col < width - 2; col++) {
                const idx = row * width + col;
                const first = emojis[idx];
                const second = emojis[idx + 1];
                const third = emojis[idx + 2];
                if (first === second && second === third && first !== '' && first !== bombEmoji) {
                    let match = [idx, idx + 1, idx + 2];
                    for (let k = col + 3; k < width; k++) {
                        const nextIdx = row * width + k;
                        if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                            match.push(nextIdx);
                        } else {
                            break;
                        }
                    }
                    matches.push(match);
                    col += match.length - 1;
                }
            }
        }
        for (let col = 0; col < width; col++) {
            for (let row = 0; row < width - 2; row++) {
                const idx = row * width + col;
                const first = emojis[idx];
                const second = emojis[idx + width];
                const third = emojis[idx + 2 * width];
                if (first === second && second === third && first !== '' && first !== bombEmoji) {
                    let match = [idx, idx + width, idx + 2 * width];
                    for (let k = row + 3; k < width; k++) {
                        const nextIdx = k * width + col;
                        if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                            match.push(nextIdx);
                        } else {
                            break;
                        }
                    }
                    matches.push(match);
                    row += match.length - 1;
                }
            }
        }
        return matches;
    }
    function findMatchesUserAction() {
        return findAllMatches();
    }
    async function checkMatches(isUserAction = false) {
        let matches = findAllMatches();
        if (isUserAction && matches.length > 0) {
            comboMultiplier = 1;
            playTotalScore = 0;
            matchCountThisMove = matches.length;
        } else if (matches.length > 0) {
            comboMultiplier += 1;
            matchCountThisMove += matches.length;
        }
        while (matches.length > 0) {
            if (comboMultiplier > 1) {
                showCombo(comboMultiplier);
            }
            for (let match of matches) {
                const popupIndex = match[Math.floor(match.length / 2)];
                const points = match.length * comboMultiplier;
                score += points;
                playTotalScore += points;
                scoreDisplay.textContent = score;
                createScorePopup(popupIndex, `+${points}`);
                const square = squares[popupIndex];
                const rect = square.getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                createParticles(match.length * 10, emojiColors[emojis[popupIndex]], rect.left - gameRect.left + rect.width / 2, rect.top - gameRect.top + rect.height / 2);
                for (let index of match) {
                    let emoji = emojis[index];
                    destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                    emojisDestroyedSinceLastBomb += 1;
                    await triggerExplosion(index);
                    if (powerUpActive && index === blinkingIndex) {
                        squares[index].classList.remove('blinking');
                        powerUpActive = false;
                        blinkingIndex = null;
                    }
                }
                if (emojisDestroyedSinceLastBomb >= 15) {
                    emojisDestroyedSinceLastBomb = 0;
                    activatePowerup();
                }
            }
            updateHighScore();
            updateTargetScore();
            if (score >= targetScore) {
                await checkLevelUp();
            }
            await fillEmptySpaces();
            matches = findAllMatches();
            if (matches.length > 0) {
                comboMultiplier += 1;
                matchCountThisMove += matches.length;
            }
            saveGameState();
        }
        if (comboMultiplier > 1) {
            hideCombo();
        }
        if (isUserAction && matchCountThisMove >= 2) {
            displayPlayTotalScore();
        }
        if (!isUserAction) {
            comboMultiplier = 1;
            matchCountThisMove = 0;
        }
        checkEndGame();
        resetIdleTimer();
    }
    function activatePowerup() {
        if (powerUpActive) return;
        const availableIndices = squares.map((_, idx) => idx).filter(idx => emojis[idx] !== bombEmoji && emojis[idx] !== dogEmoji);
        if (availableIndices.length === 0) return;
        blinkingIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
        emojis[blinkingIndex] = bombEmoji;
        setSquareContent(squares[blinkingIndex], bombEmoji);
        squares[blinkingIndex].style.setProperty('--bg-color', emojiColors[bombEmoji]);
        squares[blinkingIndex].classList.add('blinking');
        powerUpActive = true;
        emojisDestroyedSinceLastBomb = 0;
        saveGameState();
    }
    async function triggerPowerUp(index) {
        const row = Math.floor(index / width);
        const col = index % width;
        const indicesToDestroy = [];
        const directions = [
            { r: -1, c: 0 },
            { r: 1, c: 0 },
            { r: 0, c: -1 },
            { r: 0, c: 1 }
        ];
        for (let l = 1; l <= powerUpRange; l++) {
            directions.forEach(dir => {
                const newRow = row + dir.r * l;
                const newCol = col + dir.c * l;
                if (newRow >= 0 && newRow < width && newCol >= 0 && newCol < width) {
                    const idx = newRow * width + newCol;
                    if (emojis[idx] !== '') {
                        indicesToDestroy.push(idx);
                    }
                }
            });
        }
        indicesToDestroy.push(index);
        await animateExplosion(index, indicesToDestroy);
        saveGameState();
    }
    async function animateExplosion(centerIdx, indices) {
        powerUpActive = false;
        blinkingIndex = null;
        for (let i = 0; i < indices.length; i++) {
            const idx = indices[i];
            if (emojis[idx] !== '') {
                let emoji = emojis[idx];
                destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                score += 5 * comboMultiplier;
                playTotalScore += 5 * comboMultiplier;
                scoreDisplay.textContent = score;
                emojis[idx] = '';
                clearSquareContent(squares[idx]);
                squares[idx].style.removeProperty('--bg-color');
                createParticles(4 + comboMultiplier, emojiColors[emoji], squares[idx].offsetLeft + squares[idx].offsetWidth / 2, squares[idx].offsetTop + squares[idx].offsetHeight / 2);
                await delay(15);
            }
        }
        squares[centerIdx].classList.remove('blinking');
        gameContainer.classList.add('vibrate');
        setTimeout(() => {
            gameContainer.classList.remove('vibrate');
        }, 500);
        await fillEmptySpaces();
        await checkMatches(false);
        saveGameState();
    }
    function createParticles(count, color, x, y) {
        const maxParticles = 112;
        const actualCount = Math.min(count, maxParticles);
        for (let i = 0; i < actualCount; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            const greenShades = ['#00FF00', '#32CD32', '#7CFC00', '#ADFF2F'];
            const purpleShades = ['#800080', '#DA70D6', '#BA55D3', '#9932CC'];
            const colorsPool = greenShades.concat(purpleShades);
            const randomColor = colorsPool[Math.floor(Math.random() * colorsPool.length)];
            particle.style.backgroundColor = randomColor;
            const size = Math.floor(Math.random() * 7) + 6;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * (grid.offsetWidth * 0.1875);
            const tx = radius * Math.cos(angle);
            const ty = radius * Math.sin(angle);
            particle.style.setProperty('--tx', `${tx}px`);
            particle.style.setProperty('--ty', `${ty}px`);
            particlesContainer.appendChild(particle);
            setTimeout(() => {
                particle.remove();
            }, 800);
        }
    }
    function createScorePopup(index, text) {
        const popup = document.createElement('div');
        popup.classList.add('score-popup');
        const rect = squares[index].getBoundingClientRect();
        const gameRect = gameContainer.getBoundingClientRect();
        const left = rect.left - gameRect.left + rect.width / 2 - 15;
        const top = rect.top - gameRect.top + rect.height / 2 - 15;
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
        popup.textContent = text;
        popup.style.zIndex = '10';
        gameContainer.appendChild(popup);
        setTimeout(() => {
            popup.remove();
        }, 500);
        lastMatchIndex = index;
    }
function showLevelUpMessage() {
    const message = document.createElement('div');
    message.classList.add('level-up-message');
    message.innerHTML = `<img src="./levelup.png" alt="Cohete" style="width: 100px; height: 100px;"> Nivel ${level}`;
    document.body.appendChild(message);
    setTimeout(() => {
        message.remove();
    }, 1500);
}
    async function checkLevelUp() {
        if (isLevelUpInProgress) return;
        isLevelUpInProgress = true;
        previousEmojis = currentEmojis.filter(emoji => emoji !== dogEmoji);
        setTimeout(() => {
            levelUp();
            showLevelUpMessage();
            isLevelUpInProgress = false;
        }, 300);
        if (hintInterval) clearInterval(hintInterval);
        saveGameState();
    }
    function levelUp() {
        level += 1;
        levelDisplay.textContent = level;
        targetScore = getTargetScore(level);
        updateTargetScore();
        setCurrentEmojis();
        powerUpRange += 1;
        saveGameState();
    }
    function resetGame() {
        totalGamesPlayed += 1;
        totalTimePlayed += Date.now() - gameStartTime;
        saveStatistics();
        score = 0;
        level = 1;
        powerUpRange = 1;
        emojisDestroyedSinceLastBomb = 0;
        powerUpActive = false;
        blinkingIndex = null;
        isLevelUpInProgress = false;
        comboMultiplier = 1;
        playTotalScore = 0;
        matchCountThisMove = 0;
        scoreDisplay.textContent = score;
        levelDisplay.textContent = level;
        highScoreDisplay.textContent = highScore;
        targetScore = getTargetScore(level);
        updateTargetScore();
        updatePlayTotalScoreDisplay();
        gameOverDisplay.style.display = 'none';
        squares.forEach(square => {
            square.classList.remove('blinking', 'match', 'fall', 'hint');
            emojis[square.id] = '';
            clearSquareContent(square);
            square.style.removeProperty('--bg-color');
        });
        currentEmojis = [];
        previousEmojis = [];
        setCurrentEmojis();
        gameStartTime = Date.now();
        const randomColor = softColors[Math.floor(Math.random() * softColors.length)];
        grid.style.backgroundColor = randomColor;
        fillBoard();
        stabilizeBoard();
        updateTargetScore();
        resetIdleTimer();
        saveGameState();
    }
    function showInfo() {
        if (document.querySelector('.stats-popup')) return;
        const infoContainer = document.createElement('div');
        infoContainer.classList.add('stats-popup');
        const title = document.createElement('h2');
        title.textContent = 'üìä Estad√≠sticas';
        infoContainer.appendChild(title);
        const gamesPlayed = document.createElement('p');
        gamesPlayed.textContent = `üéÆ Partidas jugadas: ${totalGamesPlayed}`;
        infoContainer.appendChild(gamesPlayed);
        const timePlayed = document.createElement('p');
        const totalMinutes = Math.floor(totalTimePlayed / 60000);
        timePlayed.textContent = `‚è±Ô∏è Tiempo total jugado: ${totalMinutes} minutos`;
        infoContainer.appendChild(timePlayed);
        const emojiStatsTitle = document.createElement('h3');
        emojiStatsTitle.textContent = 'ü•á Top 10 emojis destruidos:';
        infoContainer.appendChild(emojiStatsTitle);
        const sortedEmojis = Object.entries(destroyedEmojis).sort((a, b) => b[1] - a[1]).slice(0, 10);
        const emojiList = document.createElement('ul');
        sortedEmojis.forEach(([emoji, count]) => {
            const listItem = document.createElement('li');
            if (emoji === dogEmoji) {
                listItem.innerHTML = `<img src="dog.png" alt="Dog" style="width: 20px; height: 20px; vertical-align: middle;"> - ${count}`;
            } else {
                listItem.textContent = `${emoji} - ${count}`;
            }
            emojiList.appendChild(listItem);
        });
        infoContainer.appendChild(emojiList);
        const closeButton = document.createElement('button');
        closeButton.textContent = 'üîö Cerrar';
        closeButton.addEventListener('click', () => {
            infoContainer.remove();
        });
        infoContainer.appendChild(closeButton);
        document.body.appendChild(infoContainer);
    }



// Define comboResetTimeout como una variable global si a√∫n no lo est√°
let comboResetTimeout;

function resetIdleTimer() {
    // Oculta cualquier hint previo y reinicia los temporizadores de pista
    if (hintTimeout) clearTimeout(hintTimeout);
    if (hintInterval) clearInterval(hintInterval);
    squares.forEach(square => {
        square.classList.remove('hint');
    });

    // Muestra la pista (hint) a los 3 segundos
    hintTimeout = setTimeout(() => {
        hintPossibleMatch();
    }, 3000);

    // Limpiar cualquier timeout previo de combo reset para evitar reinicios innecesarios
    if (comboResetTimeout) clearTimeout(comboResetTimeout);

    // Configura el timeout para resetear el combo multiplier y ocultar "COMBO" despu√©s de 3 segundos sin actividad
    comboResetTimeout = setTimeout(() => {
        comboMultiplier = 1; // Resetea el comboMultiplier
        hideCombo(); // Oculta "COMBO" cuando se resetea el combo
    }, 3000); // Ajuste de tiempo para el reset del combo y ocultar "COMBO"
}

// Funci√≥n para ocultar "COMBO" al finalizar el combo
function hideCombo() {
    const comboText = document.getElementById('combo-text');
    comboText.classList.remove('show');
    comboText.style.opacity = '0';
}
    function updateTargetScore() {
        targetScoreDisplay.textContent = targetScore;
    }
    function updatePlayTotalScoreDisplay() {
        playTotalScoreDisplay.textContent = `${playTotalScore}`;
    }
    function hintPossibleMatch() {
        const possibleMoves = findPossibleMoves();
        if (possibleMoves.length > 0) {
            let currentIndex = 0;
            hintInterval = setInterval(() => {
                squares.forEach(square => {
                    square.classList.remove('hint');
                });
                const move = possibleMoves[currentIndex];
                move.forEach(index => {
                    squares[index].classList.add('hint');
                });
                currentIndex = (currentIndex + 1) % possibleMoves.length;
            }, 2000);
        }
    }
    function findPossibleMoves() {
        let possibleMoves = [];
        for (let i = 0; i < width * width; i++) {
            const row = Math.floor(i / width);
            const col = i % width;
            if (col < width - 1) {
                swapEmojis(i, i + 1);
                const matches = findAllMatches();
                swapEmojis(i, i + 1);
                if (matches.length > 0) {
                    possibleMoves.push([i, i + 1]);
                }
            }
            if (row < width - 1) {
                swapEmojis(i, i + width);
                const matches = findAllMatches();
                swapEmojis(i, i + width);
                if (matches.length > 0) {
                    possibleMoves.push([i, i + width]);
                }
            }
        }
        return possibleMoves;
    }
let comboInProgress = false; // Nueva variable para seguir el estado del combo

function showCombo(multiplier) {
    if (multiplier < 2) return;

    comboInProgress = true; // Marca el inicio de un combo activo
    const comboText = document.getElementById('combo-text');
    comboText.textContent = `Combo x${multiplier}`;

    let color;
    if (multiplier <= 3) {
        color = '#FFD700';
    } else if (multiplier <= 10) {
        const progress = (multiplier - 3) / 7;
        color = interpolateColor('#FFD700', '#FFA500', progress);
    } else {
        const progress = Math.min((multiplier - 10) / 10, 1);
        color = interpolateColor('#FFA500', '#FF0000', progress);
    }
    comboText.style.color = color;
    comboText.style.opacity = '1';
    comboText.classList.add('show');

    if (window.comboTimeout) clearTimeout(window.comboTimeout);

    // Configura el timeout para permitir m√°s tiempo antes de que desaparezca
    window.comboTimeout = setTimeout(() => {
        comboInProgress = false; // Combo ha terminado
        comboText.classList.remove('show');
        comboText.style.opacity = '0';
    }, 7000);
}

// Funci√≥n para reiniciar el combo solo si no hay combos activos
function resetComboTimer() {
    if (!comboInProgress) {
        // Si no hay combo en progreso, resetea el multiplicador y oculta el texto
        comboMultiplier = 1;
        hideCombo();
    }
}

    function interpolateColor(color1, color2, progress) {
        const r1 = parseInt(color1.slice(1, 3), 16);
        const g1 = parseInt(color1.slice(3, 5), 16);
        const b1 = parseInt(color1.slice(5, 7), 16);
        const r2 = parseInt(color2.slice(1, 3), 16);
        const g2 = parseInt(color2.slice(3, 5), 16);
        const b2 = parseInt(color2.slice(5, 7), 16);
        const r = Math.round(r1 + (r2 - r1) * progress);
        const g = Math.round(g1 + (g2 - g1) * progress);
        const b = Math.round(b1 + (b2 - b1) * progress);
        return `#${(r < 16 ? '0' : '') + r.toString(16)}${(g < 16 ? '0' : '') + g.toString(16)}${(b < 16 ? '0' : '') + b.toString(16)}`;
    }
    function hideCombo() {
        comboDisplay.style.opacity = '0';
        comboDisplay.classList.remove('show');
    }
function displayPlayTotalScore() {
    if (lastMatchIndex === null) return;

    // Crear un nuevo elemento para cada puntaje total de la jugada
    const newPlayTotalScore = document.createElement('div');
    newPlayTotalScore.classList.add('play-total-score');
    newPlayTotalScore.textContent = `${playTotalScore}`;

    // Obtener el texto de reacci√≥n basado en el combo actual
    const reactionText = getReactionText(matchCountThisMove);

    // Crear un nuevo elemento para cada texto de reacci√≥n
    const newReactionText = document.createElement('div');
    newReactionText.classList.add('reaction-text');
    newReactionText.textContent = reactionText;

    // Seleccionar un color aleatorio para el texto de reacci√≥n y puntaje
    const colors = ['green-score', 'purple-score'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    newPlayTotalScore.classList.add(randomColor);
    newReactionText.classList.add(randomColor === 'green-score' ? 'purple-score' : 'green-score');

    // Posicionar el nuevo texto de reacci√≥n y el puntaje de la jugada en el centro del √∫ltimo match
    const lastSquare = squares[lastMatchIndex];
    const rect = lastSquare.getBoundingClientRect();
    const gameRect = gameContainer.getBoundingClientRect();
    const x = rect.left - gameRect.left + rect.width / 2;
    const y = rect.top - gameRect.top + rect.height / 2;

    newPlayTotalScore.style.left = `${x}px`;
    newPlayTotalScore.style.top = `${y}px`;
    newReactionText.style.left = `${x}px`;
    newReactionText.style.top = `${y + 30}px`; // Ajuste para colocar el texto de reacci√≥n ligeramente debajo

    // Agregar los nuevos elementos de puntaje total y reacci√≥n al contenedor del juego
    document.body.appendChild(newPlayTotalScore);
    document.body.appendChild(newReactionText);

    // Mostrar los elementos con la animaci√≥n
    newPlayTotalScore.classList.add('show');
    newReactionText.classList.add('show');

    // Remover los elementos despu√©s de un tiempo
    setTimeout(() => {
        newPlayTotalScore.classList.remove('show');
        newPlayTotalScore.remove();
        newReactionText.classList.remove('show');
        newReactionText.remove();
    }, 2250); // Ajuste del tiempo en pantalla si es necesario

    // Restablecer el puntaje total despu√©s de que el elemento desaparezca
    playTotalScore = 0;
    updatePlayTotalScoreDisplay();
    lastMatchIndex = null;
    matchCountThisMove = 0;
}
    function getReactionText(comboCount) {
        if (comboCount >= 25) return '¬°BoooOoM!';
        if (comboCount >= 20) return 'EXCELENTE';
        if (comboCount >= 15) return 'GUAU!';
        if (comboCount >= 10) return '√ëOS!';
        if (comboCount >= 5) return 'CHACHI';
        if (comboCount >= 3) return 'BIEN';
        return '';
    }
    async function triggerExplosion(index) {
        const square = squares[index];
        square.classList.add('explode');
        await delay(100);
        emojis[index] = '';
        clearSquareContent(square);
        square.classList.remove('explode');
    }
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async function checkEndGame() {
        const hasBomb = emojis.includes(bombEmoji);
        if (hasBomb) return;
        const possibleMoves = findPossibleMoves();
        if (possibleMoves.length === 0) {
            gameOverDisplay.style.display = 'block';
            squares.forEach(square => {
                square.removeEventListener('dragstart', dragStart);
                square.removeEventListener('dragover', dragOver);
                square.removeEventListener('drop', dragDrop);
                square.removeEventListener('dragend', dragEnd);
                square.removeEventListener('click', handleSquareClick);
                square.removeEventListener('touchstart', handleTouchStart);
                square.removeEventListener('touchend', handleTouchEnd);
            });
            if (hintInterval) clearInterval(hintInterval);
            await handleHighScore();
        }
    }
    async function handleHighScore() {
        const highScores = await getHighScores();
        if (highScores.length < 3 || score > highScores[highScores.length - 1].score) {
            const initials = prompt('¬°Nuevo High Score! Ingresa tus iniciales (3 letras):', '').toUpperCase().slice(0, 3);
            if (initials) {
                await saveHighScore(initials, score);
                alert('¬°Tu puntaje ha sido guardado en el ranking!');
            }
        }
    }
    async function getHighScores() {
        const snapshot = await db.collection('highscores')
            .orderBy('score', 'desc')
            .limit(3)
            .get();
        const highScores = [];
        snapshot.forEach(doc => {
            highScores.push({ id: doc.id, ...doc.data() });
        });
        return highScores;
    }
    async function saveHighScore(initials, scoreValue) {
        await db.collection('highscores').add({
            initials: initials,
            score: scoreValue
        });
    }
    function saveGameState() {
        const gameState = {
            score,
            level,
            emojis,
            currentEmojis,
            powerUpActive,
            blinkingIndex,
            powerUpRange,
            emojisDestroyedSinceLastBomb,
            isLevelUpInProgress
        };
        localStorage.setItem('gameState', JSON.stringify(gameState));
    }
    function loadGameState() {
        const savedState = localStorage.getItem('gameState');
        if (savedState) {
            const gameState = JSON.parse(savedState);
            score = gameState.score;
            level = gameState.level;
            emojis = gameState.emojis;
            currentEmojis = gameState.currentEmojis;
            powerUpActive = gameState.powerUpActive;
            blinkingIndex = gameState.blinkingIndex;
            powerUpRange = gameState.powerUpRange;
            emojisDestroyedSinceLastBomb = gameState.emojisDestroyedSinceLastBomb;
            isLevelUpInProgress = gameState.isLevelUpInProgress;
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            targetScore = getTargetScore(level);
            updateTargetScore();
            createBoard();
            for (let i = 0; i < emojis.length; i++) {
                setSquareContent(squares[i], emojis[i]);
                squares[i].style.setProperty('--bg-color', emojiColors[emojis[i]]);
            }
            if (powerUpActive && blinkingIndex !== null) {
                squares[blinkingIndex].classList.add('blinking');
            }
            addEventListeners();
            return true;
        }
        return false;
    }
    initializeGame();
});
</script>

</body>
</html>

