<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Match3 üéâ</title>
    <style>
        /* Reset de Estilos */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Estilos del Body */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #f0f0f0; /* Color de fondo suave */
        }

        /* Contenedor del Juego */
        .game-container {
            background: linear-gradient(135deg, #ff7e5f, #feb47b); /* Gradiente coral a naranja */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            text-align: center;
            position: relative;
            width: 90vw; /* Ancho expandido al 90% del viewport */
            max-width: 1200px; /* M√°ximo ancho para pantallas grandes */
            transition: transform 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        /* Estad√≠sticas */
        .stats {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 10px;
            width: 100%;
        }

        .stat {
            font-size: 1.2rem;
            color: #ffffff;
            position: relative;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat .counter {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ff4081;
        }

        /* Cuadr√≠cula de Juego */
        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            justify-content: center;
            align-content: start;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 10px;
            transition: all 0.3s ease-in-out;
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 90vw; /* Aumentado de 600px a 90vw para hacer el √°rea de juego m√°s grande */
            height: auto;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .grid div {
            background-color: var(--bg-color, rgba(224, 247, 250, 0.9));
            border: 1px solid #00838f;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 2rem; /* Aumentado para mejorar la visibilidad */
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            width: 100%;
            aspect-ratio: 1 / 1;
        }

.grid div img {
    width: 98%; /* Ajustado para que la imagen sea un 10% m√°s grande */
    height: 98%;
    object-fit: contain;
}
        

        .grid div:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0, 131, 143, 0.6);
            background-color: var(--bg-color, rgba(178, 235, 242, 0.9));
        }

        /* Fin del Juego */
        .game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: #d32f2f;
            text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(5deg); }
            50% { transform: translate(-50%, -50%) rotate(-5deg); }
            75% { transform: translate(-50%, -50%) rotate(5deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }

        /* Animaciones de Eliminaci√≥n y Explosi√≥n */
        .match {
            animation: matchAnimation 0.5s forwards;
        }

        @keyframes matchAnimation {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 1;
            }
            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        /* Part√≠culas */
        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            border-radius: 15px;
            z-index: 2;
        }

        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: #ff4081;
            border-radius: 50%;
            opacity: 0;
            animation: particle 1s forwards;
        }

        @keyframes particle {
            from {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            to {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(2);
            }
        }

        /* Animaci√≥n de Ca√≠da */
        .fall {
            animation: fallAnimation 0.3s forwards;
        }

        @keyframes fallAnimation {
            0% {
                transform: translateY(-100%);
            }
            100% {
                transform: translateY(0);
            }
        }

        /* Parpadeo para el Power-Up (Bomba) */
        .blinking {
            animation: blink 0.8s infinite;
            border: 2px solid gold;
            border-radius: 50%;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Efecto de vibraci√≥n en el Power-Up */
        .vibrate {
            animation: vibrate 0.5s;
        }

        @keyframes vibrate {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        /* Parpadeo de posibles matches */
        .hint {
            animation: hintAnimation 1s infinite;
        }

        @keyframes hintAnimation {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Popup de Puntuaci√≥n */
        .score-popup {
            position: absolute;
            font-size: 1rem;
            color: #ffeb3b;
            animation: popUp 1s forwards;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 5px rgba(0,0,0,0.5);
            z-index: 15;
        }

        @keyframes popUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            50% {
                opacity: 1;
                transform: translateY(-20px) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(2);
            }
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .controls button {
            background-color: #ff4081;
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls button:hover {
            background-color: #e91e63;
            transform: translateY(-2px);
        }

        /* Ventana de Estad√≠sticas */
        .stats-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            font-size: 0.9rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .stats-popup h2, .stats-popup h3 {
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 10px;
        }

        .stats-popup ul {
            list-style-type: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .stats-popup li {
            margin: 5px 0;
            text-align: center;
        }

        .stats-popup button {
            margin-top: 20px;
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
            background-color: #ff4081;
            border: none;
            color: #fff;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .stats-popup button:hover {
            background-color: #e91e63;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .stats .stat {
                font-size: 1.2rem;
            }
            .stats .counter {
                font-size: 1rem;
            }
            .game-over {
                font-size: 2rem;
            }
            .score-popup {
                font-size: 0.8rem;
            }
            .controls button {
                padding: 8px 16px;
                font-size: 1.2rem;
            }
            .stats-popup {
                font-size: 0.8rem;
            }
            .stats-popup h2, .stats-popup h3 {
                font-size: 1rem;
            }
            .stats-popup p, .stats-popup ul, .stats-popup li {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Estad√≠sticas del Juego -->
        <div class="stats">
            <div class="stat">üîÑ <span class="counter" id="matches-made">0</span></div>
            <div class="stat">üéØ <span class="counter" id="target-matches">5</span></div>
            <div class="stat">üìà <span class="counter" id="level-indicator">1</span></div>
            <div class="stat">üèÜ <span class="counter" id="high-score-value">0</span></div>
        </div>

        <!-- Cuadr√≠cula del Juego -->
        <div class="grid"></div>

        <!-- Pantalla de Fin de Juego -->
        <div id="game-over" class="game-over">üí• ¬°Juego Terminado! üí•</div>

        <!-- Controles del Juego -->
        <div class="controls">
            <button id="restart" title="Reiniciar Juego">üîÑ</button>
            <button id="info" title="Informaci√≥n">‚ÑπÔ∏è</button>
        </div>

        <!-- Contenedor de Part√≠culas -->
        <div class="particles" id="particles"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const grid = document.querySelector('.grid');
            const width = 8; // Tama√±o de la cuadr√≠cula (8x8)

            // Lista reducida de emojis para simplificar
            const allEmojis = [
'üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','üòÇ','ü§£','üòä','üòá',
'üôÇ','üôÉ','üòâ','üòå','üòç','ü•∞','üòò','üòó','üòô','üòö',
'üòã','üòõ','üòù','üòú','ü§™','ü§®','üßê','ü§ì','üòé','ü•∏',
'ü§©','ü•≥','üòè','üòí','üòû','üòî','üòü','üòï','üôÅ','‚òπÔ∏è',
'üò£','üòñ','üò´','üò©','ü•∫','üò¢','üò≠','üò§','üò†','üò°',
'ü§¨','üò≥','ü•µ','ü•∂','üò±','üò®','üò∞','üò•','üòì','ü§ó',
'ü§î','ü§≠','ü§´','ü§•','üò∂','üòê','üòë','üò¨','üôÑ','üòØ',
'üò¶','üòß','üòÆ','üò≤','ü•±','üò¥','ü§§','üò™','üòµ','ü§ê',
'ü•¥','ü§¢','ü§Æ','ü§ß','üò∑','ü§í','ü§ï','ü§ë','ü§†','üòà',
'üëø','üëπ','üë∫','ü§°','üí©','üëª','üíÄ','‚ò†Ô∏è','üëΩ','üëæ',
'ü§ñ','üéÉ','üò∫','üò∏','üòπ','üòª','üòº','üòΩ','üôÄ','üòø',
'üòæ',
// Personas y profesiones
'üßë','üë®','üë©','üë∂','üëß','üë¶','üë©‚Äçü¶∞','üë®‚Äçü¶∞','üë±‚Äç‚ôÄÔ∏è','üë±‚Äç‚ôÇÔ∏è',
'üë©‚Äçü¶±','üë®‚Äçü¶±','üë©‚Äçü¶≥','üë®‚Äçü¶≥','üë©‚Äçü¶≤','üë®‚Äçü¶≤','üßì','üë¥','üëµ','üë≤',
'üë≥‚Äç‚ôÄÔ∏è','üë≥‚Äç‚ôÇÔ∏è','üëÆ‚Äç‚ôÄÔ∏è','üëÆ‚Äç‚ôÇÔ∏è','üïµÔ∏è‚Äç‚ôÄÔ∏è','üïµÔ∏è‚Äç‚ôÇÔ∏è','üíÇ‚Äç‚ôÄÔ∏è','üíÇ‚Äç‚ôÇÔ∏è','üë∑‚Äç‚ôÄÔ∏è','üë∑‚Äç‚ôÇÔ∏è',
'ü§¥','üë∏','üëº','ü§∞','ü§±','üë©‚Äç‚öïÔ∏è','üë®‚Äç‚öïÔ∏è','üë©‚Äçüéì','üë®‚Äçüéì','üë©‚Äçüè´',
'üë®‚Äçüè´','üë©‚Äç‚öñÔ∏è','üë®‚Äç‚öñÔ∏è','üë©‚Äçüåæ','üë®‚Äçüåæ','üë©‚Äçüç≥','üë®‚Äçüç≥','üë©‚Äçüîß','üë®‚Äçüîß','üë©‚Äçüè≠',
'üë®‚Äçüè≠','üë©‚Äçüíº','üë®‚Äçüíº','üë©‚Äçüî¨','üë®‚Äçüî¨','üë©‚Äçüíª','üë®‚Äçüíª','üë©‚Äçüé§','üë®‚Äçüé§','üë©‚Äçüé®',
'üë®‚Äçüé®','üë©‚Äç‚úàÔ∏è','üë®‚Äç‚úàÔ∏è','üë©‚ÄçüöÄ','üë®‚ÄçüöÄ','üë©‚Äçüöí','üë®‚Äçüöí','üßë‚Äçüöí',
// Animales y naturaleza
'üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ',
'ü¶Å','üêÆ','üê∑','üêΩ','üê∏','üêµ','üôà','üôâ','üôä','üêí',
'üêî','üêß','üê¶','üê§','üê£','üê•','ü¶Ü','ü¶Ö','ü¶â','ü¶á',
'üê∫','üêó','üê¥','ü¶Ñ','üêù','üêõ','ü¶ã','üêå','üêö','üêû',
'üêú','üï∑Ô∏è','üï∏Ô∏è','ü¶Ç','üê¢','üêç','ü¶é','üêô','ü¶ë','ü¶ê',
'ü¶Ä','üê°','üê†','üêü','üê¨','üê≥','üêã','ü¶à','üêä','üêÖ',
'üêÜ','ü¶ì','ü¶ç','ü¶ß','üêò','ü¶è','üê™','üê´','ü¶í','üêÉ',
'üêÇ','üêÑ','üêé','üêñ','üêè','üêë','üêê','ü¶å','üêï','üê©',
'üêà','üêì','ü¶É','üïäÔ∏è','üêá','üêÅ','üêÄ','üêøÔ∏è','ü¶î',
// Comida y bebidas
'üçè','üçé','üçê','üçä','üçã','üçå','üçâ','üçá','üçì','ü´ê',
'üçà','üçí','üçë','ü•≠','üçç','ü••','ü•ù','üçÖ','üçÜ','ü•ë',
'ü•¶','ü•¨','ü•í','üå∂Ô∏è','ü´ë','üåΩ','ü•ï','ü´í','üßÑ','üßÖ',
'üçÑ','ü•ú','üå∞','üçû','ü•ê','ü•ñ','ü•®','ü•Ø','ü•û','üßá',
'üßÄ','üçñ','üçó','ü•©','ü•ì','üçî','üçü','üçï','üå≠','ü•™',
'üåÆ','üåØ','ü•ô','üßÜ','ü•ö','üç≥','üßà','ü•ò','üç≤','ü•£',
'ü•ó','üçø','üßÇ','ü•´','üç±','üçò','üçô','üçö','üçõ','üçú',
'üçù','üç†','üç¢','üç£','üç§','üç•','ü•Æ','üç°','ü•ü','ü•†',
'ü•°','ü¶™','üç¶','üçß','üç®','üç©','üç™','üéÇ','üç∞','üßÅ',
'ü•ß','üç´','üç¨','üç≠','üçÆ','üçØ','üçº','ü•õ','‚òï','üçµ',
'üç∂','üçæ','üç∑','üç∏','üçπ','ü•Ç','üç∫','üçª','ü•É','ü•§',
'üßã','üßÉ','üßâ','üßä',
// Actividades
'‚öΩ','üèÄ','üèà','‚öæ','ü•é','üéæ','üèê','üèâ','üé±','üèì',
'üè∏','ü•Ö','üèí','üèë','ü•ç','üèè','ü™Ä','ü•è','üéØ','ü™Å',
'üé≥','üéÆ','üïπÔ∏è','üé∞','üé≤','‚ôüÔ∏è','üé≠','üé®','üé§','üéß',
'üéº','üéπ','ü•Å','üé∑','üé∫','üé∏','ü™ï','üéª','ü™ó','üé¨',
'üß©','üß∏',
// Viajes y lugares
'üöó','üöï','üöô','üöå','üöé','üèéÔ∏è','üöì','üöë','üöí','üöê',
'üöö','üöõ','üöú','üõ¥','üö≤','üõµ','üèçÔ∏è','üõ∫','üö®','üöî',
'‚úàÔ∏è','üõ©Ô∏è','üõ´','üõ¨','ü™Ç','üí∫','üöÅ','üõ∂','‚õµ','üö§',
'üõ•Ô∏è','üö¢','‚öì','‚õ¥Ô∏è','ü™ù','üöß','üó∫Ô∏è','üß≠','üèûÔ∏è','üèïÔ∏è',
'üèñÔ∏è','üèúÔ∏è','üèùÔ∏è','üèüÔ∏è','üèõÔ∏è','üèóÔ∏è','üß±','ü™®','ü™µ','ü™¥',
'üåã','üóª','üèîÔ∏è','‚õ∞Ô∏è',
// Objetos
'‚åö','üì±','üì≤','üíª','‚å®Ô∏è','üñ•Ô∏è','üñ®Ô∏è','üñ±Ô∏è','üñ≤Ô∏è','üíΩ',
'üíæ','üíø','üìÄ','üìº','üì∑','üì∏','üìπ','üé•','üìΩÔ∏è','üéûÔ∏è',
'üìû','‚òéÔ∏è','üìü','üì†','üîã','üîå','üí°','üî¶','üïØÔ∏è','ü™î',
'üßØ','üí∞','ü™ô','üí¥','üíµ','üí∂','üí∑','üí∏','üí≥','üßæ',
'üíé','‚öñÔ∏è','üîß','üî®','‚öíÔ∏è','üõ†Ô∏è','‚õèÔ∏è','üî©','‚öôÔ∏è','üóúÔ∏è',
'‚öóÔ∏è','üß™','üß´','üß¨','üî¨','üî≠','üì°','üíâ','ü©∏','üíä',
'ü©π','ü©∫','üö™','üõèÔ∏è','üõãÔ∏è','ü™ë','üöΩ','üöø','üõÅ','ü™†',
'üß¥','üß∑','üßπ','üß∫','üßª','ü™£','ü™§','üßº','ü™í','üßΩ',
'üõí','üö¨','‚ö∞Ô∏è','‚ö±Ô∏è','üóø','ü™Ü','üõçÔ∏è','üß≥','üëì',
'üï∂Ô∏è','ü•Ω','ü•º','ü¶∫','üëî','üëï','üëñ','üß£','üß§','üß•',
'üß¶','üëó','üëò','üëô','üëö','üëõ','üëú','üëù','üéí','ü©¥',
'üëû','üëü','ü•æ','ü•ø','üë†','üë°','ü©∞','üë¢','üëë','üëí',
'üé©','üéì','üß¢','‚õëÔ∏è','üìø','üíÑ','üíç','üíé','üîá','üîà',
'üîâ','üîä','üì¢','üì£','üìØ','üîî','üîï','üéº','üéµ','üé∂',
'üèß','üöÆ','üö∞','‚ôø','üöπ','üö∫','üöª','üöº','üöæ','üõÇ',
'üõÉ','üõÑ','üõÖ','‚ö†Ô∏è','üö∏','‚õî','üö´','üö≥','üö≠','‚ùå',
'‚≠ï','‚úÖ','‚òëÔ∏è','‚úîÔ∏è','‚ùé','‚ûï','‚ûñ','‚ûó','‚úñÔ∏è','üí±',
'üí≤','‚öïÔ∏è','‚ôªÔ∏è','üìõ','üî∞','üÜó','üÜô','üÜí','üÜï','üÜì',
'üÜñ','üÖ∞Ô∏è','üÖ±Ô∏è','üÜé','üÜë','üÖæÔ∏è','üÜò','üõë','‚ÄºÔ∏è','‚ÅâÔ∏è',
'‚ùì','‚ùî','‚ùï','‚ùó','üîÖ','üîÜ','üî±','‚öúÔ∏è',
// Banderas
'üè≥Ô∏è','üè¥','üèÅ','üö©','üè≥Ô∏è‚Äçüåà','üè≥Ô∏è‚Äç‚ößÔ∏è','üá¶üá´','üá¶üá±','üá©üáø','üá¶üá∏',
'üá¶üá©','üá¶üá¥','üá¶üáÆ','üá¶üá∂','üá¶üá¨','üá¶üá∑','üá¶üá≤','üá¶üáº','üá¶üá∫','üá¶üáπ',
'üá¶üáø','üáßüá∏','üáßüá≠','üáßüá©','üáßüáß','üáßüáæ','üáßüá™','üáßüáø','üáßüáØ','üáßüá≤',
'üáßüáπ','üáßüá¥','üáßüá¶','üáßüáº','üáßüá∑','üáÆüá¥','üáªüá¨','üáßüá≥','üáßüá¨','üáßüá´',
'üáßüáÆ','üá®üáª','üá∞üá≠','üá®üá≤','üá®üá¶','üáÆüá®','üá∞üáæ','üá®üá´','üáπüá©','üá®üá±',
'üá®üá≥','üá®üáΩ','üá®üá®','üá®üá¥','üá∞üá≤','üá®üá¨','üá®üá©','üá®üá∞','üá®üá∑','üá®üáÆ',
'üá≠üá∑','üá®üá∫','üá®üáæ','üá®üáø','üá©üá∞','üá©üáØ','üá©üá≤','üá©üá¥','üá™üá®','üá™üá¨',
'üá∏üáª','üá¨üá∂','üá™üá∑','üá™üá™','üá™üáπ','üá´üáØ','üá´üáÆ','üá´üá∑','üá¨üá´','üáµüá´',
'üáπüá´','üá¨üá¶','üá¨üá≤','üá¨üá™','üá©üá™','üá¨üá≠','üá¨üáÆ','üá¨üá∑','üá¨üá±','üá¨üá©',
'üá¨üáµ','üá¨üá∫','üá¨üáπ','üá¨üá¨','üá¨üá≥','üá¨üáº','üá¨üáæ','üá≠üáπ','üá≠üá≥','üá≠üá∞',
'üá≠üá∫','üáÆüá∏','üáÆüá≥','üáÆüá©','üáÆüá∑','üáÆüá∂','üáÆüá™','üáÆüá±','üáÆüáπ','üáØüá≤',
'üáØüáµ','üáØüá™','üáØüá¥','üá∞üáø','üá∞üá™','üá∞üáÆ','üáΩüá∞','üá∞üáº','üá∞üá¨','üá±üá¶',
'üá±üáª','üá±üáß','üá±üá∏','üá±üá∑','üá±üáæ','üá±üáÆ','üá±üáπ','üá±üá∫','üá≤üá¥','üá≤üá∞',
'üá≤üá¨','üá≤üáº','üá≤üáæ','üá≤üáª','üá≤üá±','üá≤üáπ','üá≤üá≠','üá≤üá∂','üá≤üá∑','üá≤üá∫',
'üáæüáπ','üá≤üáΩ','üá´üá≤','üá≤üá©','üá≤üá®','üá≤üá≥','üá≤üá™','üá≤üá∏','üá≤üá¶','üá≤üáø',
'üá≤üá≤','üá≥üá¶','üá≥üá∑','üá≥üáµ','üá≥üá±','üá≥üá®','üá≥üáø','üá≥üáÆ','üá≥üá™','üá≥üá¨',
'üá≥üá∫','üá≥üá´','üá∞üáµ','üá≥üá¥','üá¥üá≤','üáµüá∞','üáµüáº','üáµüá∏','üáµüá¶','üáµüá¨',
'üáµüáæ','üáµüá™','üáµüá≠','üáµüá±','üáµüáπ','üáµüá∑','üá∂üá¶','üá∑üá¥','üá∑üá∫','üá∑üáº',
'üáßüá±','üá∏üá≠','üá∞üá≥','üá±üá®','üáµüá≤','üáªüá®','üáºüá∏','üá∏üá≤','üá∏üáπ','üá∏üá¶',
'üá∏üá≥','üá∑üá∏','üá∏üá®','üá∏üá±','üá∏üá¨','üá∏üá∞','üá∏üáÆ','üá∏üáß','üá∏üá¥','üáøüá¶',
'üá∞üá∑','üá∏üá∏','üá™üá∏','üá±üá∞','üá∏üá©','üá∏üá∑','üá∏üáø','üá∏üá™','üá®üá≠','üá∏üáæ',
'üáπüáº','üáπüáØ','üáπüáø','üáπüá≠','üáπüá±','üáπüá¨','üáπüá∞','üáπüá¥','üáπüáπ','üáπüá≥',
'üáπüá∑','üáπüá≤','üáπüá®','üá∫üá¨','üá∫üá¶','üá¶üá™','üá¨üáß','üá∫üá∏','üá∫üáæ','üá∫üáø',
'üáªüá∫','üáªüá¶','üáªüá™','üáªüá≥','üáºüá´','üá™üá≠','üáæüá™','üáøüá≤','üáøüáº',
// Otros emojis populares
'üéâ','üéä','üéà','üéÇ','üç∞','üç¶','üç©','üç™','üç´','üç¨',
'üç≠','üçÆ','üéÅ','üéÄ','üéóÔ∏è','üéüÔ∏è','üé´','üéñÔ∏è','üèÜ','ü•á',
'ü•à','ü•â','‚öΩÔ∏è','üèÄ','üèà','‚öæÔ∏è','üéæ','üèê','üèâ','üé±',
'üèì','üè∏','ü•Ö','üèí','üèë','ü•ç','üèè','ü™Ä','ü•è','üéØ',
'ü™Å','üé≥','üéÆ','üïπÔ∏è','üé∞','üé≤','‚ôüÔ∏è','üé≠','üé®','üé§',
'üéß','üéº','üéπ','ü•Å','üé∑','üé∫','üé∏','ü™ï','üéª','ü™ó',
'üé¨','üß©','üß∏',
];

            const bombEmoji = 'üí£';
            const dogEmoji = 'dog'; // Cadena espec√≠fica para identificar al perro
            let emojis = [];
            const squares = [];
            let matchesMade = 0;
            let targetMatches = 5;
            let level = 1;
            let highScore = 0;
            let destroyedEmojis = {};
            let totalGamesPlayed = 0;
            let totalTimePlayed = 0;
            let gameStartTime;
            let powerUpActive = false;
            let destroyedEmojisCount = 0;
            let blinkingIndex = null;
            let lastUserActionTime = Date.now();

            // Elementos del DOM
            const gameOverDisplay = document.getElementById('game-over');
            const matchesDisplay = document.getElementById('matches-made');
            const levelDisplay = document.getElementById('level-indicator');
            const highScoreDisplay = document.getElementById('high-score-value');
            const targetMatchesDisplay = document.getElementById('target-matches');
            const restartButton = document.getElementById('restart');
            const infoButton = document.getElementById('info');
            const particlesContainer = document.getElementById('particles');
            const gameContainer = document.querySelector('.game-container');

            let dragStartIndex;
            let dragEndIndex;
            let touchStartX = null;
            let touchStartY = null;
            let touchStartIdLocal = null;
            let emojiColors = {};

            // Asignar colores a los emojis para mejorar la visualizaci√≥n
            function assignColorsToEmojis() {
                const colors = [
                    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
                    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
                    '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
                    '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080',
                    '#ffffff', '#000000'
                ];
                let colorIndex = 0;
                allEmojis.forEach(emoji => {
                    emojiColors[emoji] = colors[colorIndex % colors.length];
                    colorIndex++;
                });
                emojiColors[bombEmoji] = '#000'; // Color especial para la bomba
                emojiColors[dogEmoji] = '#ff9900'; // Color especial para el perro
            }

            assignColorsToEmojis();

            // Inicializar el juego
            function initializeGame() {
                loadHighScore();
                loadStatistics();
                setCurrentEmojis();
                createBoard();
                gameStartTime = Date.now();
            }

            // Cargar el puntaje m√°s alto desde el almacenamiento local
            function loadHighScore() {
                const storedHighScore = localStorage.getItem('highMatches');
                if (storedHighScore) {
                    highScore = parseInt(storedHighScore);
                    highScoreDisplay.textContent = highScore;
                }
            }

            // Actualizar el puntaje m√°s alto si es necesario
            function updateHighScore() {
                if (matchesMade > highScore) {
                    highScore = matchesMade;
                    highScoreDisplay.textContent = highScore;
                    localStorage.setItem('highMatches', highScore);
                }
            }

            // Cargar estad√≠sticas desde el almacenamiento local
            function loadStatistics() {
                const storedGamesPlayed = localStorage.getItem('gamesPlayed');
                if (storedGamesPlayed) {
                    totalGamesPlayed = parseInt(storedGamesPlayed);
                }
                const storedTimePlayed = localStorage.getItem('timePlayed');
                if (storedTimePlayed) {
                    totalTimePlayed = parseInt(storedTimePlayed);
                }
                const storedDestroyedEmojis = localStorage.getItem('destroyedEmojis');
                if (storedDestroyedEmojis) {
                    destroyedEmojis = JSON.parse(storedDestroyedEmojis);
                } else {
                    destroyedEmojis = {};
                }
            }

            // Guardar estad√≠sticas en el almacenamiento local
            function saveStatistics() {
                localStorage.setItem('gamesPlayed', totalGamesPlayed);
                localStorage.setItem('timePlayed', totalTimePlayed);
                localStorage.setItem('destroyedEmojis', JSON.stringify(destroyedEmojis));
            }

            // Configurar la lista actual de emojis basados en el nivel
            function setCurrentEmojis() {
                if (level === 1) {
                    currentEmojis = getRandomUniqueEmojis(allEmojis, 4); // Inicialmente 4 emojis
                    if (!currentEmojis.includes(dogEmoji)) {
                        currentEmojis.push(dogEmoji);
                    }
                } else {
                    // Cada nivel a√±ade un emoji nuevo
                    const newEmoji = getNewEmoji();
                    if (newEmoji) {
                        currentEmojis.push(newEmoji);
                    }

                    // Cada dos niveles a partir del nivel 3, elimina un emoji antiguo (excepto el perro)
                    if (level >= 3 && level % 2 === 1) {
                        removeOldEmoji();
                    }
                }
            }

            // Obtener emojis √∫nicos aleatorios
            function getRandomUniqueEmojis(array, number) {
                const filteredArray = array.filter(emoji => emoji !== bombEmoji && emoji !== dogEmoji);
                const shuffled = filteredArray.slice().sort(() => 0.5 - Math.random());
                return shuffled.slice(0, number);
            }

            // Obtener un nuevo emoji para agregar
            function getNewEmoji() {
                const availableEmojis = allEmojis.filter(emoji => !currentEmojis.includes(emoji) && emoji !== bombEmoji && emoji !== dogEmoji);
                if (availableEmojis.length === 0) return null;
                const randomIndex = Math.floor(Math.random() * availableEmojis.length);
                return availableEmojis[randomIndex];
            }

            // Remover un emoji antiguo (excepto el perro)
            function removeOldEmoji() {
                const removableEmojis = currentEmojis.filter(emoji => emoji !== dogEmoji);
                if (removableEmojis.length === 0) return;
                const emojiToRemove = removableEmojis[Math.floor(Math.random() * removableEmojis.length)];
                const removeIndex = currentEmojis.indexOf(emojiToRemove);
                if (removeIndex !== -1) {
                    currentEmojis.splice(removeIndex, 1);
                }
            }

            // Crear el tablero de juego
            function createBoard() {
                grid.innerHTML = '';
                squares.length = 0;
                for (let i = 0; i < width * width; i++) {
                    const square = document.createElement('div');
                    square.setAttribute('draggable', true);
                    square.setAttribute('id', i);
                    grid.appendChild(square);
                    squares.push(square);
                }
                fillBoard();
                addEventListeners();
            }

            // Rellenar el tablero con emojis aleatorios y estabilizarlo
            function fillBoard() {
                for (let i = 0; i < squares.length; i++) {
                    if (emojis[i] === undefined || emojis[i] === '') {
                        let randomEmoji = getRandomEmoji();
                        emojis[i] = randomEmoji;
                        setSquareContent(squares[i], randomEmoji);
                        squares[i].style.setProperty('--bg-color', emojiColors[randomEmoji]);
                    }
                }
                stabilizeBoard();
            }

            // Asegurar que no haya matches al inicio
            function stabilizeBoard() {
                let matches = findAllMatches();
                while (matches.length > 0) {
                    matches.forEach(match => {
                        match.forEach(index => {
                            let newEmoji = getRandomEmoji();
                            emojis[index] = newEmoji;
                            setSquareContent(squares[index], newEmoji);
                            squares[index].style.setProperty('--bg-color', emojiColors[newEmoji]);
                        });
                    });
                    matches = findAllMatches();
                }
            }

            // Obtener un emoji aleatorio de la lista actual
            function getRandomEmoji() {
                const rand = Math.floor(Math.random() * currentEmojis.length);
                return currentEmojis[rand];
            }

            // Establecer el contenido de una celda
            function setSquareContent(square, emoji) {
                if (emoji === dogEmoji) {
                    square.innerHTML = '<img src="Dog.png" alt="Dog">'; // Aseg√∫rate de que Dog.png est√© en la ruta correcta
                } else {
                    square.innerHTML = '';
                    square.textContent = emoji;
                }
            }

            // Limpiar el contenido de una celda
            function clearSquareContent(square) {
                square.innerHTML = '';
                square.textContent = '';
            }

            // Agregar eventos a las celdas y controles
            function addEventListeners() {
                squares.forEach(square => {
                    square.addEventListener('dragstart', dragStart);
                    square.addEventListener('dragover', dragOver);
                    square.addEventListener('drop', dragDrop);
                    square.addEventListener('dragend', dragEnd);
                    square.addEventListener('click', handleSquareClick);
                });
                squares.forEach(square => {
                    square.addEventListener('touchstart', handleTouchStart, { passive: true });
                    square.addEventListener('touchend', handleTouchEnd, { passive: true });
                });
                restartButton.addEventListener('click', resetGame);
                infoButton.addEventListener('click', showInfo);
                document.addEventListener('mousedown', resetIdleTimer);
                document.addEventListener('touchstart', resetIdleTimer);
            }

            // Manejo de eventos de arrastrar y soltar
            function dragStart(e) {
                dragStartIndex = parseInt(this.id);
                this.classList.add('dragging');
            }

            function dragOver(e) {
                e.preventDefault();
            }

            function dragDrop(e) {
                dragEndIndex = parseInt(this.id);
                if (isAdjacent(dragStartIndex, dragEndIndex)) {
                    swapEmojis(dragStartIndex, dragEndIndex);
                    if (findMatchesUserAction().length > 0) {
                        checkMatches(true);
                    } else {
                        swapEmojis(dragEndIndex, dragStartIndex);
                    }
                }
            }

            function dragEnd() {
                squares.forEach(square => square.classList.remove('dragging'));
            }

            // Manejo de eventos t√°ctiles
            function handleTouchStart(e) {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    touchStartIdLocal = parseInt(this.id);
                }
            }

            function handleTouchEnd(e) {
                if (touchStartX === null || touchStartY === null) return;
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const threshold = 30;
                let dragEndIndexLocal = touchStartIdLocal;
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > threshold) {
                        dragEndIndexLocal = touchStartIdLocal + 1;
                    } else if (deltaX < -threshold) {
                        dragEndIndexLocal = touchStartIdLocal - 1;
                    }
                } else {
                    if (deltaY > threshold) {
                        dragEndIndexLocal = touchStartIdLocal + width;
                    } else if (deltaY < -threshold) {
                        dragEndIndexLocal = touchStartIdLocal - width;
                    }
                }
                if (isAdjacent(touchStartIdLocal, dragEndIndexLocal) && dragEndIndexLocal >= 0 && dragEndIndexLocal < width * width) {
                    swapEmojis(touchStartIdLocal, dragEndIndexLocal);
                    if (findMatchesUserAction().length > 0) {
                        checkMatches(true);
                    } else {
                        swapEmojis(dragEndIndexLocal, touchStartIdLocal);
                    }
                }
                touchStartX = null;
                touchStartY = null;
                touchStartIdLocal = null;
            }

            // Manejar clic en una celda (para activar power-ups)
            function handleSquareClick(e) {
                const index = parseInt(this.id);
                if (powerUpActive && index === blinkingIndex && emojis[index] === bombEmoji) {
                    triggerPowerUp(index);
                }
            }

            // Verificar si dos √≠ndices son adyacentes
            function isAdjacent(index1, index2) {
                const row1 = Math.floor(index1 / width);
                const col1 = index1 % width;
                const row2 = Math.floor(index2 / width);
                const col2 = index2 % width;
                const rowDiff = Math.abs(row1 - row2);
                const colDiff = Math.abs(col1 - col2);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            // Intercambiar emojis entre dos √≠ndices
            function swapEmojis(index1, index2) {
                const tempEmoji = emojis[index1];
                emojis[index1] = emojis[index2];
                emojis[index2] = tempEmoji;
                setSquareContent(squares[index1], emojis[index1]);
                setSquareContent(squares[index2], emojis[index2]);
                squares[index1].style.setProperty('--bg-color', emojiColors[emojis[index1]]);
                squares[index2].style.setProperty('--bg-color', emojiColors[emojis[index2]]);

                updatePowerUpPosition(index1, index2);
            }

            // Actualizar la posici√≥n del power-up si est√° activo
            function updatePowerUpPosition(oldIndex, newIndex) {
                if (powerUpActive) {
                    if (oldIndex === blinkingIndex) {
                        squares[blinkingIndex].classList.remove('blinking');
                        blinkingIndex = newIndex;
                        squares[blinkingIndex].classList.add('blinking');
                    } else if (newIndex === blinkingIndex) {
                        squares[blinkingIndex].classList.remove('blinking');
                        blinkingIndex = oldIndex;
                        squares[blinkingIndex].classList.add('blinking');
                    }
                }
            }

            // Encontrar todos los matches en la cuadr√≠cula
            function findAllMatches() {
                const matches = [];
                // Horizontal Matches
                for (let row = 0; row < width; row++) {
                    for (let col = 0; col < width - 2; col++) {
                        const idx = row * width + col;
                        const first = emojis[idx];
                        const second = emojis[idx + 1];
                        const third = emojis[idx + 2];
                        if (first === second && second === third && first !== '' && first !== bombEmoji) {
                            let match = [idx, idx + 1, idx + 2];
                            // Evitar matches que incluyan el power-up
                            if (match.some(index => emojis[index] === bombEmoji)) continue;
                            // Extender el match si hay m√°s emojis iguales
                            for (let k = col + 3; k < width; k++) {
                                const nextIdx = row * width + k;
                                if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                                    match.push(nextIdx);
                                } else {
                                    break;
                                }
                            }
                            matches.push(match);
                            col += match.length - 1;
                        }
                    }
                }
                // Vertical Matches
                for (let col = 0; col < width; col++) {
                    for (let row = 0; row < width - 2; row++) {
                        const idx = row * width + col;
                        const first = emojis[idx];
                        const second = emojis[idx + width];
                        const third = emojis[idx + 2 * width];
                        if (first === second && second === third && first !== '' && first !== bombEmoji) {
                            let match = [idx, idx + width, idx + 2 * width];
                            // Evitar matches que incluyan el power-up
                            if (match.some(index => emojis[index] === bombEmoji)) continue;
                            // Extender el match si hay m√°s emojis iguales
                            for (let k = row + 3; k < width; k++) {
                                const nextIdx = k * width + col;
                                if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                                    match.push(nextIdx);
                                } else {
                                    break;
                                }
                            }
                            matches.push(match);
                            row += match.length - 1;
                        }
                    }
                }
                return matches;
            }

            // Encontrar matches como resultado de una acci√≥n del usuario
            function findMatchesUserAction() {
                return findAllMatches();
            }

            // Verificar y procesar matches
            function checkMatches(isUserAction = false) {
                let matches = findAllMatches();
                if (matches.length === 0) {
                    // Opcional: verificar si el juego ha terminado
                    checkEndGame();
                    return;
                }
                destroyedEmojisCount += matches.reduce((sum, match) => sum + match.length, 0);
                if (isUserAction) {
                    matches.forEach(match => {
                        let matchLength = match.length;
                        let matchPoints = 1;
                        if (matchLength === 4) {
                            matchPoints = 2;
                        } else if (matchLength >= 5) {
                            matchPoints = 3;
                        }
                        matchesMade += matchPoints;
                        matchesDisplay.textContent = matchesMade;
                        createScorePopup(match[0], `+${matchPoints}`);
                    });
                    updateHighScore();

                    // Verificar si se ha alcanzado el objetivo de matches para subir de nivel
                    if (matchesMade >= targetMatches) {
                        levelUp();
                    }
                }
                matches.forEach(match => {
                    match.forEach(index => {
                        let emoji = emojis[index];
                        destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                        emojis[index] = '';
                        clearSquareContent(squares[index]);
                        squares[index].style.removeProperty('--bg-color');

                        // Manejar la eliminaci√≥n del power-up si est√° en este √≠ndice
                        if (powerUpActive && index === blinkingIndex) {
                            squares[index].classList.remove('blinking');
                            powerUpActive = false;
                            blinkingIndex = null;
                        }
                    });
                });
                checkPowerup();
                setTimeout(() => {
                    fillEmptySpaces();
                }, 500);
            }

            // Rellenar espacios vac√≠os despu√©s de eliminar matches
            function fillEmptySpaces() {
                for (let col = 0; col < width; col++) {
                    let emptySpots = 0;
                    for (let row = width - 1; row >= 0; row--) {
                        const idx = row * width + col;
                        if (emojis[idx] === '' || emojis[idx] === undefined) {
                            emptySpots++;
                        } else if (emptySpots > 0) {
                            const newIdx = (row + emptySpots) * width + col;
                            const movingEmoji = emojis[idx];
                            emojis[newIdx] = movingEmoji;
                            setSquareContent(squares[newIdx], movingEmoji);
                            squares[newIdx].style.setProperty('--bg-color', emojiColors[movingEmoji]);
                            emojis[idx] = '';
                            clearSquareContent(squares[idx]);
                            squares[idx].style.removeProperty('--bg-color');
                            squares[newIdx].classList.add('fall');
                            setTimeout(() => {
                                squares[newIdx].classList.remove('fall');
                            }, 300);

                            // Actualizar la posici√≥n del power-up si es necesario
                            if (powerUpActive && movingEmoji === bombEmoji) {
                                squares[blinkingIndex].classList.remove('blinking');
                                blinkingIndex = newIdx;
                                squares[blinkingIndex].classList.add('blinking');
                            }
                        }
                    }

                    // Insertar nuevos emojis en los espacios vac√≠os en la parte superior
                    for (let row = 0; row < emptySpots; row++) {
                        const idx = row * width + col;
                        const newEmoji = getRandomEmoji();
                        emojis[idx] = newEmoji;
                        setSquareContent(squares[idx], newEmoji);
                        squares[idx].style.setProperty('--bg-color', emojiColors[newEmoji]);
                        squares[idx].classList.add('fall');
                        setTimeout(() => {
                            squares[idx].classList.remove('fall');
                        }, 300);

                        // Actualizar la posici√≥n del power-up si es necesario
                        if (powerUpActive && newEmoji === bombEmoji) {
                            if (blinkingIndex !== idx) {
                                if (blinkingIndex !== null) {
                                    squares[blinkingIndex].classList.remove('blinking');
                                }
                                blinkingIndex = idx;
                                squares[blinkingIndex].classList.add('blinking');
                            }
                        }
                    }
                }

                // Despu√©s de rellenar, verificar si hay nuevos matches
                setTimeout(() => {
                    checkMatches();
                }, 500);
            }

            // Verificar si se puede activar un power-up
            function checkPowerup() {
                if (destroyedEmojisCount >= 10 && !powerUpActive) {
                    activatePowerup();
                }
            }

            // Activar un power-up (bomba)
            function activatePowerup() {
                const availableIndices = [];
                for (let i = 0; i < width * width; i++) {
                    if (emojis[i] !== '' && emojis[i] !== bombEmoji) {
                        availableIndices.push(i);
                    }
                }
                if (availableIndices.length === 0) return;
                blinkingIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                emojis[blinkingIndex] = bombEmoji;
                setSquareContent(squares[blinkingIndex], bombEmoji);
                squares[blinkingIndex].style.setProperty('--bg-color', emojiColors[bombEmoji]);
                squares[blinkingIndex].classList.add('blinking');
                powerUpActive = true;
                destroyedEmojisCount = 0;
            }

            // Disparar el power-up (bomba) cuando se hace clic en ella
            function triggerPowerUp(index) {
                const row = Math.floor(index / width);
                const col = index % width;
                const indicesToDestroy = [];
                // Destruir en rango horizontal
                for (let c = col - 2; c <= col + 2; c++) {
                    if (c >= 0 && c < width) {
                        const idx = row * width + c;
                        if (emojis[idx] !== '') {
                            indicesToDestroy.push(idx);
                        }
                    }
                }
                // Destruir en rango vertical
                for (let r = row - 2; r <= row + 2; r++) {
                    if (r >= 0 && r < width) {
                        const idx = r * width + col;
                        if (emojis[idx] !== '') {
                            indicesToDestroy.push(idx);
                        }
                    }
                }
                const uniqueIndices = [...new Set(indicesToDestroy)];
                gameContainer.classList.add('vibrate');
                setTimeout(() => {
                    gameContainer.classList.remove('vibrate');
                }, 500);
                uniqueIndices.forEach(idx => {
                    setTimeout(() => {
                        let emoji = emojis[idx];
                        destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                        emojis[idx] = '';
                        clearSquareContent(squares[idx]);
                        squares[idx].style.removeProperty('--bg-color');
                    }, 0);
                });
                powerUpActive = false;
                squares[index].classList.remove('blinking');
                blinkingIndex = null;
                setTimeout(() => {
                    fillEmptySpaces();
                }, 500);
            }

            // Crear part√≠culas de animaci√≥n (opcional)
            function createParticles(count, color, x, y) {
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    particle.style.backgroundColor = color;
                    const rect = grid.getBoundingClientRect();
                    particle.style.left = `${x - rect.left + 27.5}px`;
                    particle.style.top = `${y - rect.top + 27.5}px`;
                    particle.style.setProperty('--tx', `${Math.random() * 100 - 50}px`);
                    particle.style.setProperty('--ty', `${Math.random() * 100 - 50}px`);
                    particlesContainer.appendChild(particle);
                    setTimeout(() => {
                        particle.remove();
                    }, 1000);
                }
            }

            // Crear un popup de puntuaci√≥n al hacer un match
            function createScorePopup(index, text) {
                const popup = document.createElement('div');
                popup.classList.add('score-popup');
                const rect = squares[index].getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                const left = rect.left - gameRect.left + rect.width / 2 - 10;
                const top = rect.top - gameRect.top + rect.height / 2 - 10;
                popup.style.left = `${left}px`;
                popup.style.top = `${top}px`;
                popup.textContent = text;
                popup.style.zIndex = '10';
                gameContainer.appendChild(popup);
                setTimeout(() => {
                    popup.remove();
                }, 1000);
            }

            // Verificar si es hora de subir de nivel
            function checkLevelUp() {
                if (matchesMade >= targetMatches) {
                    levelUp();
                }
            }

            // Subir de nivel y actualizar la lista de emojis
            function levelUp() {
                level += 1;
                levelDisplay.textContent = level;
                targetMatches += 5;
                targetMatchesDisplay.textContent = targetMatches;
                setCurrentEmojis();
                matchesMade = 0; // Resetear contador de matches al subir de nivel
                matchesDisplay.textContent = matchesMade;
                fillBoard(); // Rellenar el tablero para incluir nuevos emojis
            }

            // Reiniciar el juego
            function resetGame() {
                totalGamesPlayed += 1;
                totalTimePlayed += Date.now() - gameStartTime;
                saveStatistics();
                matchesMade = 0;
                targetMatches = 5;
                level = 1;
                destroyedEmojisCount = 0;
                powerUpActive = false;
                blinkingIndex = null;
                matchesDisplay.textContent = matchesMade;
                targetMatchesDisplay.textContent = targetMatches;
                levelDisplay.textContent = level;
                gameOverDisplay.style.display = 'none';
                squares.forEach(square => {
                    square.classList.remove('blinking', 'match', 'fall', 'hint');
                    emojis[square.id] = '';
                    clearSquareContent(square);
                    square.style.removeProperty('--bg-color');
                });
                currentEmojis = [];
                setCurrentEmojis();
                gameStartTime = Date.now();
                fillBoard();
                // No volver a a√±adir event listeners aqu√≠ para evitar duplicados
            }

            // Mostrar informaci√≥n y estad√≠sticas del juego
            function showInfo() {
                // Verificar si ya existe un popup para evitar duplicados
                if (document.querySelector('.stats-popup')) return;

                const infoContainer = document.createElement('div');
                infoContainer.classList.add('stats-popup');

                const title = document.createElement('h2');
                title.textContent = 'Estad√≠sticas';
                infoContainer.appendChild(title);

                const gamesPlayed = document.createElement('p');
                gamesPlayed.textContent = `Partidas jugadas: ${totalGamesPlayed}`;
                infoContainer.appendChild(gamesPlayed);

                const timePlayed = document.createElement('p');
                const totalMinutes = Math.floor(totalTimePlayed / 60000);
                timePlayed.textContent = `Tiempo total jugado: ${totalMinutes} minutos`;
                infoContainer.appendChild(timePlayed);

                const emojiStatsTitle = document.createElement('h3');
                emojiStatsTitle.textContent = 'Top 10 emojis destruidos:';
                infoContainer.appendChild(emojiStatsTitle);

                const sortedEmojis = Object.entries(destroyedEmojis).sort((a, b) => b[1] - a[1]).slice(0, 10);
                const emojiList = document.createElement('ul');
                sortedEmojis.forEach(([emoji, count]) => {
                    const listItem = document.createElement('li');
                    if (emoji === dogEmoji) {
                        listItem.innerHTML = `<img src="Dog.png" alt="Dog" style="width: 20px; height: 20px; vertical-align: middle;"> - ${count}`;
                    } else {
                        listItem.textContent = `${emoji} - ${count}`;
                    }
                    emojiList.appendChild(listItem);
                });
                infoContainer.appendChild(emojiList);

                const closeButton = document.createElement('button');
                closeButton.textContent = 'Cerrar';
                closeButton.addEventListener('click', () => {
                    infoContainer.remove();
                });
                infoContainer.appendChild(closeButton);

                document.body.appendChild(infoContainer);
            }

            // Resetear el temporizador de inactividad
            function resetIdleTimer() {
                lastUserActionTime = Date.now();
            }

            // Mostrar una pista de posibles movimientos
            function hintPossibleMatch() {
                const possibleMoves = findPossibleMoves();
                if (possibleMoves.length > 0) {
                    const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    randomMove.forEach(index => {
                        squares[index].classList.add('hint');
                        setTimeout(() => {
                            squares[index].classList.remove('hint');
                        }, 1000);
                    });
                }
            }

            // Mostrar una pista despu√©s de 6 segundos de inactividad
            setInterval(() => {
                if (Date.now() - lastUserActionTime >= 6000) {
                    hintPossibleMatch();
                }
            }, 1000);

            // Verificar si el juego ha terminado
            function checkEndGame() {
                const possibleMoves = findPossibleMoves();
                if (possibleMoves.length === 0) {
                    gameOverDisplay.style.display = 'block';
                    squares.forEach(square => {
                        square.removeEventListener('dragstart', dragStart);
                        square.removeEventListener('dragover', dragOver);
                        square.removeEventListener('drop', dragDrop);
                        square.removeEventListener('dragend', dragEnd);
                        square.removeEventListener('click', handleSquareClick);
                        square.removeEventListener('touchstart', handleTouchStart);
                        square.removeEventListener('touchend', handleTouchEnd);
                    });
                }
            }

            // Encontrar posibles movimientos que crean matches
            function findPossibleMoves() {
                let possibleMoves = [];
                for (let i = 0; i < width * width; i++) {
                    const row = Math.floor(i / width);
                    const col = i % width;
                    if (col < width - 1) {
                        swapEmojis(i, i + 1);
                        if (findAllMatches().length > 0) {
                            possibleMoves.push([i, i + 1]);
                        }
                        swapEmojis(i, i + 1);
                    }
                    if (row < width - 1) {
                        swapEmojis(i, i + width);
                        if (findAllMatches().length > 0) {
                            possibleMoves.push([i, i + width]);
                        }
                        swapEmojis(i, i + width);
                    }
                }
                return possibleMoves;
            }

            // Inicializar el juego al cargar la p√°gina
            initializeGame();

            // Explicaci√≥n de la Aparici√≥n de Nuevos Emojis
            /*
                La mec√°nica de generaci√≥n de nuevos emojis est√° manejada principalmente por la funci√≥n `fillEmptySpaces()`. 
                Aqu√≠ est√° c√≥mo funciona:

                1. **Detecci√≥n de Espacios Vac√≠os**:
                    - Despu√©s de que se detectan y eliminan los emojis que forman un match, algunos espacios en la cuadr√≠cula quedan vac√≠os.
                    - La funci√≥n `fillEmptySpaces()` recorre cada columna de la cuadr√≠cula.

                2. **Ca√≠da de Emojis Existentes**:
                    - Para cada columna, cuenta cu√°ntos espacios vac√≠os (`emptySpots`) hay.
                    - Luego, recorre la columna desde abajo hacia arriba. Si encuentra un emoji que no est√° vac√≠o y hay espacios vac√≠os debajo, mueve ese emoji hacia abajo tantas posiciones como espacios vac√≠os existan.
                    - Aplica una clase CSS `.fall` para animar la ca√≠da del emoji hacia su nueva posici√≥n.

                3. **Inserci√≥n de Nuevos Emojis**:
                    - Despu√©s de mover los emojis existentes hacia abajo, hay que llenar los espacios vac√≠os en la parte superior de la columna.
                    - Para cada espacio vac√≠o en la parte superior, genera un nuevo emoji aleatorio de la lista `currentEmojis`.
                    - Asigna este nuevo emoji a la celda vac√≠a correspondiente y aplica la clase `.fall` para animar su aparici√≥n desde la parte superior hacia abajo.

                4. **Manejo del Power-Up durante la Ca√≠da**:
                    - Si el emoji que se est√° moviendo es un power-up (bombEmoji), la funci√≥n actualiza la variable `blinkingIndex` para reflejar su nueva posici√≥n.
                    - Esto asegura que el power-up mantenga su funcionalidad y animaci√≥n de parpadeo correctamente.

                5. **Actualizaci√≥n y Verificaci√≥n Continua**:
                    - Una vez que los nuevos emojis se han insertado y las animaciones han finalizado, la funci√≥n `checkMatches()` se llama nuevamente para detectar si hay nuevos matches formados por los emojis reci√©n insertados.
                    - Esto permite que el juego contin√∫e de manera fluida, generando y desplazando nuevos emojis seg√∫n el progreso del jugador.

                **Resumen**:
                La clave est√° en mover los emojis existentes hacia abajo para llenar los espacios vac√≠os y luego insertar nuevos emojis en la parte superior de cada columna, permitiendo que caigan naturalmente al llenar los huecos. Esta mec√°nica evita la sustituci√≥n masiva de emojis y mantiene la din√°mica del juego fluida y visualmente atractiva.
            */
        });
    </script>
</body>
</html>