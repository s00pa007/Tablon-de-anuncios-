<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Match-3 Game</title>
<style>
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'Arial', sans-serif;
    overflow: hidden;
    background-color: #f0f0f0;
    padding: 20px 0;
}

.game-container {
    background-color: #6a11cb;
    padding: 20px;
    border-radius: 15px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    text-align: center;
    position: relative;
    width: 100%;
    max-width: 900px;
    transition: transform 0.3s;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
    height: auto;
}

.stats {
    display: flex;
    justify-content: space-around;
    align-items: center;
    margin-bottom: 20px;
    width: 90%;
    flex-wrap: wrap;
}

.stat {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stat-label, .stat-count {
    background-color: #4a148c;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.6rem;
    font-weight: bold;
    color: #ffffff;
}

.stat.score .stat-label {
    background-color: #1e88e5;
}

.stat.level .stat-label {
    background-color: #43a047;
}

.stat.target-score .stat-label {
    background-color: #f4511e;
}

.stat.high-score .stat-label {
    background-color: #8e24aa;
}

.controls {
    margin-top: 20px;
    display: flex;
    gap: 15px;
    justify-content: center;
}

.controls button {
    background-color: #3949ab;
    border: none;
    color: white;
    padding: 4px 10px;
    margin: 0 5px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.6rem;
    font-weight: bold;
    font-family: 'Arial', sans-serif;
    transition: background-color 0.3s, transform 0.2s;
    box-shadow: 0 6px 10px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
}

.controls button:hover {
    background-color: #303f9f;
    transform: translateY(-2px);
}

.grid {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 2px;
    justify-content: center;
    align-content: start;
    background-image: url('galaxy.png');
    background-size: cover;
    background-repeat: no-repeat;
    padding: 10px;
    border-radius: 10px;
    transition: all 0.3s ease-in-out;
    position: relative;
    overflow: hidden;
    width: 100%;
    max-width: 800px;
    aspect-ratio: 1 / 1;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    flex-grow: 1;
}

.grid div {
    background-color: var(--bg-color, rgba(224, 247, 250, 0.95));
    border: 2px solid #00838f;
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-size: 1.8rem;
    transition: transform 0.15s, box-shadow 0.15s, background-color 0.2s;
    position: relative;
    overflow: hidden;
    box-shadow: 0 3px 7px rgba(0,0,0,0.15);
    color: #fff;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    width: 100%;
    aspect-ratio: 1 / 1;
}

.grid div img {
    width: 60%;
    height: 60%;
    object-fit: contain;
}

.grid div img.dog-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.grid div:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(0, 131, 143, 0.8);
    background-color: var(--bg-color, rgba(178, 235, 242, 0.95));
}

.game-over {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2rem;
    color: #d32f2f;
    text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
    z-index: 10;
    animation: shake 0.5s;
    font-weight: bold;
    font-family: 'Arial', sans-serif;
}

@keyframes shake {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    25% { transform: translate(-50%, -50%) rotate(5deg); }
    50% { transform: translate(-50%, -50%) rotate(-5deg); }
    75% { transform: translate(-50%, -50%) rotate(5deg); }
    100% { transform: translate(-50%, -50%) rotate(0deg); }
}

.match {
    animation: matchAnimation 0.2s forwards;
}

@keyframes matchAnimation {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.3);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 0;
    }
}

.score-popup {
    position: absolute;
    font-size: 0.48rem;
    color: #ffeb3b;
    animation: popUp 0.8s forwards;
    pointer-events: none;
    font-weight: bold;
    text-shadow: 1px 1px 5px rgba(0,0,0,0.5);
    z-index: 25;
}

.score-popup.move-score {
    font-family: 'Arial', sans-serif;
    font-size: 1.8rem;
    font-weight: 900;
    text-align: center;
    animation: popUpScore 1s forwards;
    z-index: 25;
    filter: drop-shadow(0 0 10px rgba(0,0,0,0.3));
}

.score-popup.move-score-green {
    color: #32CD32;
    text-shadow: 
    0 0 5px #FFD700,
    0 0 10px #FFD700,
    0 0 15px #FFD700;
}

.score-popup.move-score-purple {
    color: #9932CC;
    text-shadow: 
    0 0 5px #FFFFFF,
    0 0 10px #FFFFFF,
    0 0 15px #FFFFFF;
}

@keyframes popUpScore {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1.5);
    }
}

.particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
    border-radius: 15px;
    z-index: 2;
}

.particle {
    position: absolute;
    width: 6px;
    height: 6px;
    background: #ff4081;
    border-radius: 50%;
    opacity: 0;
    animation: particle 0.6s forwards;
    pointer-events: none;
}

@keyframes particle {
    from {
        opacity: 1;
        transform: translate(0, 0) scale(1);
    }
    to {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(1.5);
    }
}

.fall {
    animation: fallAnimation 0.6s ease-out forwards;
}

@keyframes fallAnimation {
    0% {
        transform: translateY(-100%);
    }
    100% {
        transform: translateY(0);
    }
}

.level-up-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #0077ff, #00c6ff, #ffffff);
    padding: 20px 40px;
    border-radius: 10px;
    font-size: 2.64rem;
    font-family: 'Arial', sans-serif;
    color: #000;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);
    animation: levelUpAnimation 1.5s forwards;
    z-index: 1000;
}

@keyframes levelUpAnimation {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

.combo-text {
    font-size: 2.112em;
    font-weight: 900;
    font-family: 'Arial', sans-serif;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    letter-spacing: -0.05em;
    text-shadow:
    0 0 8px white,
    0 0 16px white,
    0 0 24px #0077ff,
    -3px -3px 0 #0077ff,
    3px -3px 0 #0077ff,
    -3px 3px 0 #0077ff,
    3px 3px 0 #0077ff;
}

.combo-text.show {
    opacity: 1;
    animation: fadeInOut 3s forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { opacity: 0; }
}

@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.blinking {
    animation: blink 1s infinite;
}

.hint {
    border: 2px solid #ffffff;
    animation: blink 0.8s infinite;
}

@media (max-width: 800px) {
    .grid {
        width: 100%;
        height: 100%;
    }
}

@media (max-width: 600px) {
    .stats .stat-label, .stats .stat-count {
        font-size: 0.48rem;
    }
    .game-over {
        font-size: 1.6rem;
    }
    .score-popup {
        font-size: 0.384rem;
    }
    .controls button {
        padding: 3px 6px;
        font-size: 0.48rem;
    }
    .game-container {
        padding: 10px 0;
    }
    .controls {
        margin-top: 10px;
    }
    .grid {
        padding: 5px;
    }
    .stat-label, .stat-count {
        font-size: 0.48rem;
    }
    .combo-text {
        font-size: 1.68em;
        letter-spacing: -0.04em;
    }
}
</style>
</head>
<body>
<div class="game-container">
    <div class="combo-text" id="combo-text"></div>

    <div class="stats">
        <div class="stat score">
            <span class="stat-label">PuntuaciÃ³n</span><span class="stat-count" id="score">0</span>
        </div>
        <div class="stat level">
            <span class="stat-label">Nivel</span><span class="stat-count" id="level-indicator">1</span>
        </div>
        <div class="stat target-score">
            <span class="stat-label">Objetivo</span><span class="stat-count" id="target-score">3000</span>
        </div>
        <div class="stat high-score">
            <span class="stat-label">Mejor PuntuaciÃ³n</span><span class="stat-count" id="high-score-value">0</span>
        </div>
    </div>
    <div class="grid">
    </div>
    <div id="particles" class="particles"></div>
    <div id="game-over" class="game-over">Juego Terminado</div>
    <div class="controls">
        <button id="restart">Reiniciar</button>
        <button id="info">InformaciÃ³n</button>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const grid = document.querySelector('.grid');
    const width = 8;
    const allEmojis = ['ðŸ˜€','ðŸ˜ƒ','ðŸ˜„','ðŸ˜','ðŸ˜†','ðŸ˜…','ðŸ˜‚','ðŸ¤£','ðŸ˜Š','ðŸ˜‡',
    'ðŸ™‚','ðŸ™ƒ','ðŸ˜‰','ðŸ˜Œ','ðŸ˜','ðŸ¥°','ðŸ˜˜','ðŸ˜—','ðŸ˜™','ðŸ˜š',
    'ðŸ˜‹','ðŸ˜›','ðŸ˜','ðŸ˜œ','ðŸ¤ª','ðŸ¤¨','ðŸ§','ðŸ¤“','ðŸ˜Ž','ðŸ¥¸',
    'ðŸ¤©','ðŸ¥³','ðŸ˜','ðŸ˜’','ðŸ˜ž','ðŸ˜”','ðŸ˜Ÿ','ðŸ˜•','ðŸ™','â˜¹ï¸',
    'ðŸ˜£','ðŸ˜–','ðŸ˜«','ðŸ˜©','ðŸ¥º','ðŸ˜¢','ðŸ˜­','ðŸ˜¤','ðŸ˜ ','ðŸ˜¡',
    'ðŸ¤¬','ðŸ˜³','ðŸ¥µ','ðŸ¥¶','ðŸ˜±','ðŸ˜¨','ðŸ˜°','ðŸ˜¥','ðŸ˜“','ðŸ¤—',
    'ðŸ¤”','ðŸ¤­','ðŸ¤«','ðŸ¤¥','ðŸ˜¶','ðŸ˜','ðŸ˜‘','ðŸ˜¬','ðŸ™„','ðŸ˜¯',
    'ðŸ˜¦','ðŸ˜§','ðŸ˜®','ðŸ˜²','ðŸ¥±','ðŸ˜´','ðŸ¤¤','ðŸ˜ª','ðŸ˜µ','ðŸ¤',
    'ðŸ¥´','ðŸ¤¢','ðŸ¤®','ðŸ¤§','ðŸ˜·','ðŸ¤’','ðŸ¤•','ðŸ¤‘','ðŸ¤ ','ðŸ˜ˆ',
    'ðŸ‘¿','ðŸ‘¹','ðŸ‘º','ðŸ¤¡','ðŸ’©','ðŸ‘»','ðŸ’€','â˜ ï¸','ðŸ‘½','ðŸ‘¾',
    'ðŸ¤–','ðŸŽƒ','ðŸ˜º','ðŸ˜¸','ðŸ˜¹','ðŸ˜»','ðŸ˜¼','ðŸ˜½','ðŸ™€','ðŸ˜¿',
    'ðŸ˜¾',
    // Personas y profesiones
    'ðŸ§‘','ðŸ‘¨','ðŸ‘©','ðŸ‘¶','ðŸ‘§','ðŸ‘¦','ðŸ‘©â€ðŸ¦°','ðŸ‘¨â€ðŸ¦°','ðŸ‘±â€â™€ï¸','ðŸ‘±â€â™‚ï¸',
    'ðŸ‘©â€ðŸ¦±','ðŸ‘¨â€ðŸ¦±','ðŸ‘©â€ðŸ¦³','ðŸ‘¨â€ðŸ¦³','ðŸ‘©â€ðŸ¦²','ðŸ‘¨â€ðŸ¦²','ðŸ§“','ðŸ‘´','ðŸ‘µ','ðŸ‘²',
    'ðŸ‘³â€â™€ï¸','ðŸ‘³â€â™‚ï¸','ðŸ‘®â€â™€ï¸','ðŸ‘®â€â™‚ï¸','ðŸ•µï¸â€â™€ï¸','ðŸ•µï¸â€â™‚ï¸','ðŸ’‚â€â™€ï¸','ðŸ’‚â€â™‚ï¸','ðŸ‘·â€â™€ï¸','ðŸ‘·â€â™‚ï¸',
    'ðŸ¤´','ðŸ‘¸','ðŸ‘¼','ðŸ¤°','ðŸ¤±','ðŸ‘©â€âš•ï¸','ðŸ‘¨â€âš•ï¸','ðŸ‘©â€ðŸŽ“','ðŸ‘¨â€ðŸŽ“','ðŸ‘©â€ðŸ«',
    'ðŸ‘¨â€ðŸ«','ðŸ‘©â€âš–ï¸','ðŸ‘¨â€âš–ï¸','ðŸ‘©â€ðŸŒ¾','ðŸ‘¨â€ðŸŒ¾','ðŸ‘©â€ðŸ³','ðŸ‘¨â€ðŸ³','ðŸ‘©â€ðŸ”§','ðŸ‘¨â€ðŸ”§','ðŸ‘©â€ðŸ­',
    'ðŸ‘¨â€ðŸ­','ðŸ‘©â€ðŸ’¼','ðŸ‘¨â€ðŸ’¼','ðŸ‘©â€ðŸ”¬','ðŸ‘¨â€ðŸ”¬','ðŸ‘©â€ðŸ’»','ðŸ‘¨â€ðŸ’»','ðŸ‘©â€ðŸŽ¤','ðŸ‘¨â€ðŸŽ¤','ðŸ‘©â€ðŸŽ¨',
    'ðŸ‘¨â€ðŸŽ¨','ðŸ‘©â€âœˆï¸','ðŸ‘¨â€âœˆï¸','ðŸ‘©â€ðŸš€','ðŸ‘¨â€ðŸš€','ðŸ‘©â€ðŸš’','ðŸ‘¨â€ðŸš’','ðŸ§‘â€ðŸš’',
    // Animales y naturaleza
    'ðŸ¶','ðŸ±','ðŸ­','ðŸ¹','ðŸ°','ðŸ¦Š','ðŸ»','ðŸ¼','ðŸ¨','ðŸ¯',
    'ðŸ¦','ðŸ®','ðŸ·','ðŸ½','ðŸ¸','ðŸµ','ðŸ™ˆ','ðŸ™‰','ðŸ™Š','ðŸ’',
    'ðŸ”','ðŸ§','ðŸ¦','ðŸ¤','ðŸ£','ðŸ¥','ðŸ¦†','ðŸ¦…','ðŸ¦‰','ðŸ¦‡',
    'ðŸº','ðŸ—','ðŸ´','ðŸ¦„','ðŸ','ðŸ›','ðŸ¦‹','ðŸŒ','ðŸš','ðŸž',
    'ðŸœ','ðŸ•·ï¸','ðŸ•¸ï¸','ðŸ¦‚','ðŸ¢','ðŸ','ðŸ¦Ž','ðŸ™','ðŸ¦‘','ðŸ¦',
    'ðŸ¦€','ðŸ¡','ðŸ ','ðŸŸ','ðŸ¬','ðŸ³','ðŸ‹','ðŸ¦ˆ','ðŸŠ','ðŸ…',
    'ðŸ†','ðŸ¦“','ðŸ¦','ðŸ¦§','ðŸ˜','ðŸ¦','ðŸª','ðŸ«','ðŸ¦’','ðŸƒ',
    'ðŸ‚','ðŸ„','ðŸŽ','ðŸ–','ðŸ','ðŸ‘','ðŸ','ðŸ¦Œ','ðŸ•','ðŸ©',
    'ðŸˆ','ðŸ“','ðŸ¦ƒ','ðŸ•Šï¸','ðŸ‡','ðŸ','ðŸ€','ðŸ¿ï¸','ðŸ¦”',
    // Comida y bebidas
    'ðŸ','ðŸŽ','ðŸ','ðŸŠ','ðŸ‹','ðŸŒ','ðŸ‰','ðŸ‡','ðŸ“','ðŸ«',
    'ðŸˆ','ðŸ’','ðŸ‘','ðŸ¥­','ðŸ','ðŸ¥¥','ðŸ¥','ðŸ…','ðŸ†','ðŸ¥‘',
    'ðŸ¥¦','ðŸ¥¬','ðŸ¥’','ðŸŒ¶ï¸','ðŸ«‘','ðŸŒ½','ðŸ¥•','ðŸ«’','ðŸ§„','ðŸ§…',
    'ðŸ„','ðŸ¥œ','ðŸŒ°','ðŸž','ðŸ¥','ðŸ¥–','ðŸ¥¨','ðŸ¥¯','ðŸ¥ž','ðŸ§‡',
    'ðŸ§€','ðŸ–','ðŸ—','ðŸ¥©','ðŸ¥“','ðŸ”','ðŸŸ','ðŸ•','ðŸŒ­','ðŸ¥ª',
    'ðŸŒ®','ðŸŒ¯','ðŸ¥™','ðŸ§†','ðŸ¥š','ðŸ³','ðŸ§ˆ','ðŸ¥˜','ðŸ²','ðŸ¥£',
    'ðŸ¥—','ðŸ¿','ðŸ§‚','ðŸ¥«','ðŸ±','ðŸ˜','ðŸ™','ðŸš','ðŸ›','ðŸœ',
    'ðŸ','ðŸ ','ðŸ¢','ðŸ£','ðŸ¤','ðŸ¥','ðŸ¥®','ðŸ¡','ðŸ¥Ÿ','ðŸ¥ ',
    'ðŸ¥¡','ðŸ¦ª','ðŸ¦','ðŸ§','ðŸ¨','ðŸ©','ðŸª','ðŸŽ‚','ðŸ°','ðŸ§',
    'ðŸ¥§','ðŸ«','ðŸ¬','ðŸ­','ðŸ®','ðŸ¯','ðŸ¼','ðŸ¥›','â˜•','ðŸµ',
    'ðŸ¶','ðŸ¾','ðŸ·','ðŸ¸','ðŸ¹','ðŸ¥‚','ðŸº','ðŸ»','ðŸ¥ƒ','ðŸ¥¤',
    'ðŸ§‹','ðŸ§ƒ','ðŸ§‰','ðŸ§Š',
    // Actividades
    'âš½','ðŸ€','ðŸˆ','âš¾','ðŸ¥Ž','ðŸŽ¾','ðŸ','ðŸ‰','ðŸŽ±','ðŸ“',
    'ðŸ¸','ðŸ¥…','ðŸ’','ðŸ‘','ðŸ¥','ðŸ','ðŸª€','ðŸ¥','ðŸŽ¯','ðŸª',
    'ðŸŽ³','ðŸŽ®','ðŸ•¹ï¸','ðŸŽ°','ðŸŽ²','â™Ÿï¸','ðŸŽ­','ðŸŽ¨','ðŸŽ¤','ðŸŽ§',
    'ðŸŽ¼','ðŸŽ¹','ðŸ¥','ðŸŽ·','ðŸŽº','ðŸŽ¸','ðŸª•','ðŸŽ»','ðŸª—','ðŸŽ¬',
    'ðŸ§©','ðŸ§¸',
    // Viajes y lugares
    'ðŸš—','ðŸš•','ðŸš™','ðŸšŒ','ðŸšŽ','ðŸŽï¸','ðŸš“','ðŸš‘','ðŸš’','ðŸš',
    'ðŸšš','ðŸš›','ðŸšœ','ðŸ›´','ðŸš²','ðŸ›µ','ðŸï¸','ðŸ›º','ðŸš¨','ðŸš”',
    'âœˆï¸','ðŸ›©ï¸','ðŸ›«','ðŸ›¬','ðŸª‚','ðŸ’º','ðŸš','ðŸ›¶','â›µ','ðŸš¤',
    'ðŸ›¥ï¸','ðŸš¢','âš“','â›´ï¸','ðŸª','ðŸš§','ðŸ—ºï¸','ðŸ§­','ðŸžï¸','ðŸ•ï¸',
    'ðŸ–ï¸','ðŸœï¸','ðŸï¸','ðŸŸï¸','ðŸ›ï¸','ðŸ—ï¸','ðŸ§±','ðŸª¨','ðŸªµ','ðŸª´',
    'ðŸŒ‹','ðŸ—»','ðŸ”ï¸','â›°ï¸',
    // Objetos
    'âŒš','ðŸ“±','ðŸ“²','ðŸ’»','âŒ¨ï¸','ðŸ–¥ï¸','ðŸ–¨ï¸','ðŸ–±ï¸','ðŸ–²ï¸','ðŸ’½',
    'ðŸ’¾','ðŸ’¿','ðŸ“€','ðŸ“¼','ðŸ“·','ðŸ“¸','ðŸ“¹','ðŸŽ¥','ðŸ“½ï¸','ðŸŽžï¸',
    'ðŸ“ž','â˜Žï¸','ðŸ“Ÿ','ðŸ“ ','ðŸ”‹','ðŸ”Œ','ðŸ’¡','ðŸ”¦','ðŸ•¯ï¸','ðŸª”',
    'ðŸ§¯','ðŸ’°','ðŸª™','ðŸ’´','ðŸ’µ','ðŸ’¶','ðŸ’·','ðŸ’¸','ðŸ’³','ðŸ§¾',
    'ðŸ’Ž','âš–ï¸','ðŸ”§','ðŸ”¨','âš’ï¸','ðŸ› ï¸','â›ï¸','ðŸ”©','âš™ï¸','ðŸ—œï¸',
    'âš—ï¸','ðŸ§ª','ðŸ§«','ðŸ§¬','ðŸ”¬','ðŸ”­','ðŸ“¡','ðŸ’‰','ðŸ©¸','ðŸ’Š',
    'ðŸ©¹','ðŸ©º','ðŸšª','ðŸ›ï¸','ðŸ›‹ï¸','ðŸª‘','ðŸš½','ðŸš¿','ðŸ›','ðŸª ',
    'ðŸ§´','ðŸ§·','ðŸ§¹','ðŸ§º','ðŸ§»','ðŸª£','ðŸª¤','ðŸ§¼','ðŸª’','ðŸ§½',
    'ðŸ›’','ðŸš¬','âš°ï¸','âš±ï¸','ðŸ—¿','ðŸª†','ðŸ›ï¸','ðŸ§³','ðŸ‘“',
    'ðŸ•¶ï¸','ðŸ¥½','ðŸ¥¼','ðŸ¦º','ðŸ‘”','ðŸ‘•','ðŸ‘–','ðŸ§£','ðŸ§¤','ðŸ§¥',
    'ðŸ§¦','ðŸ‘—','ðŸ‘˜','ðŸ‘™','ðŸ‘š','ðŸ‘›','ðŸ‘œ','ðŸ‘','ðŸŽ’','ðŸ©´',
    'ðŸ‘ž','ðŸ‘Ÿ','ðŸ¥¾','ðŸ¥¿','ðŸ‘ ','ðŸ‘¡','ðŸ©°','ðŸ‘¢','ðŸ‘‘','ðŸ‘’',
    'ðŸŽ©','ðŸŽ“','ðŸ§¢','â›‘ï¸','ðŸ“¿','ðŸ’„','ðŸ’','ðŸ’Ž','ðŸ”‡','ðŸ”ˆ',
    'ðŸ”‰','ðŸ”Š','ðŸ“¢','ðŸ“£','ðŸ“¯','ðŸ””','ðŸ”•','ðŸŽ¼','ðŸŽµ','ðŸŽ¶',
    'ðŸ§','ðŸš®','ðŸš°','â™¿','ðŸš¹','ðŸšº','ðŸš»','ðŸš¼','ðŸš¾','ðŸ›‚',
    'ðŸ›ƒ','ðŸ›„','ðŸ›…','âš ï¸','ðŸš¸','â›”','ðŸš«','ðŸš³','ðŸš­','âŒ',
    'â­•','âœ…','â˜‘ï¸','âœ”ï¸','âŽ','âž•','âž–','âž—','âœ–ï¸','ðŸ’±',
    'ðŸ’²','âš•ï¸','â™»ï¸','ðŸ“›','ðŸ”°','ðŸ†—','ðŸ†™','ðŸ†’','ðŸ†•','ðŸ†“',
    'ðŸ†–','ðŸ…°ï¸','ðŸ…±ï¸','ðŸ†Ž','ðŸ†‘','ðŸ…¾ï¸','ðŸ†˜','ðŸ›‘','â€¼ï¸','â‰ï¸',
    'â“','â”','â•','â—','ðŸ”…','ðŸ”†','ðŸ”±','âšœï¸',
    // Banderas
    'ðŸ³ï¸','ðŸ´','ðŸ','ðŸš©','ðŸ³ï¸â€ðŸŒˆ','ðŸ³ï¸â€âš§ï¸','ðŸ‡¦ðŸ‡«','ðŸ‡¦ðŸ‡±','ðŸ‡©ðŸ‡¿','ðŸ‡¦ðŸ‡¸',
    'ðŸ‡¦ðŸ‡©','ðŸ‡¦ðŸ‡´','ðŸ‡¦ðŸ‡®','ðŸ‡¦ðŸ‡¶','ðŸ‡¦ðŸ‡¬','ðŸ‡¦ðŸ‡·','ðŸ‡¦ðŸ‡²','ðŸ‡¦ðŸ‡¼','ðŸ‡¦ðŸ‡º','ðŸ‡¦ðŸ‡¹',
    'ðŸ‡¦ðŸ‡¿','ðŸ‡§ðŸ‡¸','ðŸ‡§ðŸ‡­','ðŸ‡§ðŸ‡©','ðŸ‡§ðŸ‡§','ðŸ‡§ðŸ‡¾','ðŸ‡§ðŸ‡ª','ðŸ‡§ðŸ‡¿','ðŸ‡§ðŸ‡¯','ðŸ‡§ðŸ‡²',
    'ðŸ‡§ðŸ‡¹','ðŸ‡§ðŸ‡´','ðŸ‡§ðŸ‡¦','ðŸ‡§ðŸ‡¼','ðŸ‡§ðŸ‡·','ðŸ‡®ðŸ‡´','ðŸ‡»ðŸ‡¬','ðŸ‡§ðŸ‡³','ðŸ‡§ðŸ‡¬','ðŸ‡§ðŸ‡«',
    'ðŸ‡§ðŸ‡®','ðŸ‡¨ðŸ‡»','ðŸ‡°ðŸ‡­','ðŸ‡¨ðŸ‡²','ðŸ‡¨ðŸ‡¦','ðŸ‡®ðŸ‡¨','ðŸ‡°ðŸ‡¾','ðŸ‡¨ðŸ‡«','ðŸ‡¹ðŸ‡©','ðŸ‡¨ðŸ‡±',
    'ðŸ‡¨ðŸ‡³','ðŸ‡¨ðŸ‡½','ðŸ‡¨ðŸ‡¨','ðŸ‡¨ðŸ‡´','ðŸ‡°ðŸ‡²','ðŸ‡¨ðŸ‡¬','ðŸ‡¨ðŸ‡©','ðŸ‡¨ðŸ‡°','ðŸ‡¨ðŸ‡·','ðŸ‡¨ðŸ‡®',
    'ðŸ‡­ðŸ‡·','ðŸ‡¨ðŸ‡º','ðŸ‡¨ðŸ‡¾','ðŸ‡¨ðŸ‡¿','ðŸ‡©ðŸ‡°','ðŸ‡©ðŸ‡¯','ðŸ‡©ðŸ‡²','ðŸ‡©ðŸ‡´','ðŸ‡ªðŸ‡¨','ðŸ‡ªðŸ‡¬',
    'ðŸ‡¸ðŸ‡»','ðŸ‡¬ðŸ‡¶','ðŸ‡ªðŸ‡·','ðŸ‡ªðŸ‡ª','ðŸ‡ªðŸ‡¹','ðŸ‡«ðŸ‡¯','ðŸ‡«ðŸ‡®','ðŸ‡«ðŸ‡·','ðŸ‡¬ðŸ‡«','ðŸ‡µðŸ‡«',
    'ðŸ‡¹ðŸ‡«','ðŸ‡¬ðŸ‡¦','ðŸ‡¬ðŸ‡²','ðŸ‡¬ðŸ‡ª','ðŸ‡©ðŸ‡ª','ðŸ‡¬ðŸ‡­','ðŸ‡¬ðŸ‡®','ðŸ‡¬ðŸ‡·','ðŸ‡¬ðŸ‡±','ðŸ‡¬ðŸ‡©',
    'ðŸ‡¬ðŸ‡µ','ðŸ‡¬ðŸ‡º','ðŸ‡¬ðŸ‡¹','ðŸ‡¬ðŸ‡¬','ðŸ‡¬ðŸ‡³','ðŸ‡¬ðŸ‡¼','ðŸ‡¬ðŸ‡¾','ðŸ‡­ðŸ‡¹','ðŸ‡­ðŸ‡³','ðŸ‡­ðŸ‡°',
    'ðŸ‡­ðŸ‡º','ðŸ‡®ðŸ‡¸','ðŸ‡®ðŸ‡³','ðŸ‡®ðŸ‡©','ðŸ‡®ðŸ‡·','ðŸ‡®ðŸ‡¶','ðŸ‡®ðŸ‡ª','ðŸ‡®ðŸ‡±','ðŸ‡®ðŸ‡¹','ðŸ‡¯ðŸ‡²',
    'ðŸ‡¯ðŸ‡µ','ðŸ‡¯ðŸ‡ª','ðŸ‡¯ðŸ‡´','ðŸ‡°ðŸ‡¿','ðŸ‡°ðŸ‡ª','ðŸ‡°ðŸ‡®','ðŸ‡½ðŸ‡°','ðŸ‡°ðŸ‡¼','ðŸ‡°ðŸ‡¬','ðŸ‡±ðŸ‡¦',
    'ðŸ‡±ðŸ‡»','ðŸ‡±ðŸ‡§','ðŸ‡±ðŸ‡¸','ðŸ‡±ðŸ‡·','ðŸ‡±ðŸ‡¾','ðŸ‡±ðŸ‡®','ðŸ‡±ðŸ‡¹','ðŸ‡±ðŸ‡º','ðŸ‡²ðŸ‡´','ðŸ‡²ðŸ‡°',
    'ðŸ‡²ðŸ‡¬','ðŸ‡²ðŸ‡¼','ðŸ‡²ðŸ‡¾','ðŸ‡²ðŸ‡»','ðŸ‡²ðŸ‡±','ðŸ‡²ðŸ‡¹','ðŸ‡²ðŸ‡­','ðŸ‡²ðŸ‡¶','ðŸ‡²ðŸ‡·','ðŸ‡²ðŸ‡º',
    'ðŸ‡¾ðŸ‡¹','ðŸ‡²ðŸ‡½','ðŸ‡«ðŸ‡²','ðŸ‡²ðŸ‡©','ðŸ‡²ðŸ‡¨','ðŸ‡²ðŸ‡³','ðŸ‡²ðŸ‡ª','ðŸ‡²ðŸ‡¸','ðŸ‡²ðŸ‡¦','ðŸ‡²ðŸ‡¿',
    'ðŸ‡²ðŸ‡²','ðŸ‡³ðŸ‡¦','ðŸ‡³ðŸ‡·','ðŸ‡³ðŸ‡µ','ðŸ‡³ðŸ‡±','ðŸ‡³ðŸ‡¨','ðŸ‡³ðŸ‡¿','ðŸ‡³ðŸ‡®','ðŸ‡³ðŸ‡ª','ðŸ‡³ðŸ‡¬',
    'ðŸ‡³ðŸ‡º','ðŸ‡³ðŸ‡«','ðŸ‡°ðŸ‡µ','ðŸ‡³ðŸ‡´','ðŸ‡´ðŸ‡²','ðŸ‡µðŸ‡°','ðŸ‡µðŸ‡¼','ðŸ‡µðŸ‡¸','ðŸ‡µðŸ‡¦','ðŸ‡µðŸ‡¬',
    'ðŸ‡µðŸ‡¾','ðŸ‡µðŸ‡ª','ðŸ‡µðŸ‡­','ðŸ‡µðŸ‡±','ðŸ‡µðŸ‡¹','ðŸ‡µðŸ‡·','ðŸ‡¶ðŸ‡¦','ðŸ‡·ðŸ‡´','ðŸ‡·ðŸ‡º','ðŸ‡·ðŸ‡¼',
    'ðŸ‡§ðŸ‡±','ðŸ‡¸ðŸ‡­','ðŸ‡°ðŸ‡³','ðŸ‡±ðŸ‡¨','ðŸ‡µðŸ‡²','ðŸ‡»ðŸ‡¨','ðŸ‡¼ðŸ‡¸','ðŸ‡¸ðŸ‡²','ðŸ‡¸ðŸ‡¹','ðŸ‡¸ðŸ‡¦',
    'ðŸ‡¸ðŸ‡³','ðŸ‡·ðŸ‡¸','ðŸ‡¸ðŸ‡¨','ðŸ‡¸ðŸ‡±','ðŸ‡¸ðŸ‡¬','ðŸ‡¸ðŸ‡°','ðŸ‡¸ðŸ‡®','ðŸ‡¸ðŸ‡§','ðŸ‡¸ðŸ‡´','ðŸ‡¿ðŸ‡¦',
    'ðŸ‡°ðŸ‡·','ðŸ‡¸ðŸ‡¸','ðŸ‡ªðŸ‡¸','ðŸ‡±ðŸ‡°','ðŸ‡¸ðŸ‡©','ðŸ‡¸ðŸ‡·','ðŸ‡¸ðŸ‡¿','ðŸ‡¸ðŸ‡ª','ðŸ‡¨ðŸ‡­','ðŸ‡¸ðŸ‡¾',
    'ðŸ‡¹ðŸ‡¼','ðŸ‡¹ðŸ‡¯','ðŸ‡¹ðŸ‡¿','ðŸ‡¹ðŸ‡­','ðŸ‡¹ðŸ‡±','ðŸ‡¹ðŸ‡¬','ðŸ‡¹ðŸ‡°','ðŸ‡¹ðŸ‡´','ðŸ‡¹ðŸ‡¹','ðŸ‡¹ðŸ‡³',
    'ðŸ‡¹ðŸ‡·','ðŸ‡¹ðŸ‡²','ðŸ‡¹ðŸ‡¨','ðŸ‡ºðŸ‡¬','ðŸ‡ºðŸ‡¦','ðŸ‡¦ðŸ‡ª','ðŸ‡¬ðŸ‡§','ðŸ‡ºðŸ‡¸','ðŸ‡ºðŸ‡¾','ðŸ‡ºðŸ‡¿',
    'ðŸ‡»ðŸ‡º','ðŸ‡»ðŸ‡¦','ðŸ‡»ðŸ‡ª','ðŸ‡»ðŸ‡³','ðŸ‡¼ðŸ‡«','ðŸ‡ªðŸ‡­','ðŸ‡¾ðŸ‡ª','ðŸ‡¿ðŸ‡²','ðŸ‡¿ðŸ‡¼',
    // Otros emojis populares
    'ðŸŽ‰','ðŸŽŠ','ðŸŽˆ','ðŸŽ‚','ðŸ°','ðŸ¦','ðŸ©','ðŸª','ðŸ«','ðŸ¬',
    'ðŸ­','ðŸ®','ðŸŽ','ðŸŽ€','ðŸŽ—ï¸','ðŸŽŸï¸','ðŸŽ«','ðŸŽ–ï¸','ðŸ†','ðŸ¥‡',
    'ðŸ¥ˆ','ðŸ¥‰','âš½ï¸','ðŸ€','ðŸˆ','âš¾ï¸','ðŸŽ¾','ðŸ','ðŸ‰','ðŸŽ±',
    'ðŸ“','ðŸ¸','ðŸ¥…','ðŸ’','ðŸ‘','ðŸ¥','ðŸ','ðŸª€','ðŸ¥','ðŸŽ¯',
    'ðŸª','ðŸŽ³','ðŸŽ®','ðŸ•¹ï¸','ðŸŽ°','ðŸŽ²','â™Ÿï¸','ðŸŽ­','ðŸŽ¨','ðŸŽ¤',
    'ðŸŽ§','ðŸŽ¼','ðŸŽ¹','ðŸ¥','ðŸŽ·','ðŸŽº','ðŸŽ¸','ðŸª•','ðŸŽ»','ðŸª—',
    'ðŸŽ¬','ðŸ§©','ðŸ§¸',
    ];
    const bombEmoji = 'ðŸ’£';
    const dogEmoji = 'ðŸ¶';
    let emojis = [];
    const squares = [];
    let score = 0;
    let level = 1;
    let highScore = 0;
    let destroyedEmojis = {};
    let totalGamesPlayed = 0;
    let totalTimePlayed = 0;
    let gameStartTime;
    let powerUpActive = false;
    let blinkingIndex = null;
    let currentEmojis = [];
    let powerUpRange = 1;
    let previousEmojis = [];
    let isLevelUpInProgress = false;
    let emojisDestroyedSinceLastBomb = 0;
    let totalMatchesInCombo = 0;
    const gameOverDisplay = document.getElementById('game-over');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level-indicator');
    const highScoreDisplay = document.getElementById('high-score-value');
    const targetScoreDisplay = document.getElementById('target-score');
    const restartButton = document.getElementById('restart');
    const infoButton = document.getElementById('info');
    const particlesContainer = document.getElementById('particles');
    const gameContainer = document.querySelector('.game-container');
    const comboDisplay = document.getElementById('combo-text');
    let dragStartIndex;
    let dragEndIndex;
    let touchStartX = null;
    let touchStartY = null;
    let touchStartIdLocal = null;
    let emojiColors = {};

    function assignColorsToEmojis() {
        const colors = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'];
        let colorIndex = 0;
        allEmojis.forEach(emoji => {
            emojiColors[emoji] = colors[colorIndex % colors.length];
            colorIndex++;
        });
        emojiColors[bombEmoji] = '#000';
        emojiColors[dogEmoji] = '#ff9900';
    }
    assignColorsToEmojis();

    const softColors = ['#FFEBEE', '#F3E5F5', '#E3F2FD', '#E8F5E9', '#FFF3E0'];

    function getTargetScore(level) {
        if (level === 1) return 3000;
        if (level === 2) return 5000;
        if (level === 3) return 6000;
        return 6000 + (level - 3) * 1000;
    }

    function initializeGame() {
        const randomColor = softColors[Math.floor(Math.random() * softColors.length)];
        grid.style.backgroundColor = randomColor;
        loadHighScore();
        loadStatistics();
        setCurrentEmojis(true);
        createBoard();
        gameStartTime = Date.now();
        updateTargetScore();
        stabilizeBoard();
    }

    function loadHighScore() {
        const storedHighScore = localStorage.getItem('highScore');
        if (storedHighScore) {
            highScore = parseInt(storedHighScore);
            highScoreDisplay.textContent = highScore;
        }
    }

    function updateHighScore() {
        if (score > highScore) {
            highScore = score;
            highScoreDisplay.textContent = highScore;
            localStorage.setItem('highScore', highScore);
        }
    }

    function loadStatistics() {
        const storedGamesPlayed = localStorage.getItem('gamesPlayed');
        if (storedGamesPlayed) {
            totalGamesPlayed = parseInt(storedGamesPlayed);
        }
        const storedTimePlayed = localStorage.getItem('timePlayed');
        if (storedTimePlayed) {
            totalTimePlayed = parseInt(storedTimePlayed);
        }
        const storedDestroyedEmojis = localStorage.getItem('destroyedEmojis');
        if (storedDestroyedEmojis) {
            destroyedEmojis = JSON.parse(storedDestroyedEmojis);
        } else {
            destroyedEmojis = {};
        }
    }

    function saveStatistics() {
        localStorage.setItem('gamesPlayed', totalGamesPlayed);
        localStorage.setItem('timePlayed', totalTimePlayed);
        localStorage.setItem('destroyedEmojis', JSON.stringify(destroyedEmojis));
    }

    function setCurrentEmojis(renewAll = false) {
        if (renewAll) {
            currentEmojis = [dogEmoji];
            const numberOfNewEmojis = Math.min(2 + level, allEmojis.length);
            const newEmojis = getRandomUniqueEmojis(allEmojis, numberOfNewEmojis);
            currentEmojis = currentEmojis.concat(newEmojis);
        } else {
            const newEmoji = getNewEmoji();
            if (newEmoji) {
                currentEmojis.push(newEmoji);
            }
        }
    }

    function getRandomUniqueEmojis(array, number) {
        const filteredArray = array.filter(emoji => 
            emoji !== bombEmoji && 
            emoji !== dogEmoji && 
            !previousEmojis.includes(emoji) &&
            !currentEmojis.includes(emoji)
        );
        for (let i = filteredArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [filteredArray[i], filteredArray[j]] = [filteredArray[j], filteredArray[i]];
        }
        return filteredArray.slice(0, number);
    }

    function getNewEmoji() {
        const availableEmojis = allEmojis.filter(emoji => 
            !currentEmojis.includes(emoji) && 
            emoji !== bombEmoji && 
            emoji !== dogEmoji &&
            !previousEmojis.includes(emoji)
        );
        if (availableEmojis.length === 0) return null;
        const randomIndex = Math.floor(Math.random() * availableEmojis.length);
        return availableEmojis[randomIndex];
    }

    function createBoard() {
        grid.innerHTML = '';
        squares.length = 0;
        for (let i = 0; i < width * width; i++) {
            const square = document.createElement('div');
            square.setAttribute('draggable', true);
            square.setAttribute('id', i);
            grid.appendChild(square);
            squares.push(square);
        }
        fillBoard();
        addEventListeners();
    }

    function fillBoard() {
        for (let i = 0; i < squares.length; i++) {
            if (emojis[i] === undefined || emojis[i] === '') {
                let randomEmoji = getRandomEmoji();
                if (randomEmoji) {
                    emojis[i] = randomEmoji;
                    setSquareContent(squares[i], randomEmoji);
                    squares[i].style.setProperty('--bg-color', emojiColors[randomEmoji]);
                }
            }
        }
    }

    function stabilizeBoard() {
        let matches = findAllMatches();
        while (matches.length > 0) {
            matches.forEach(match => {
                match.forEach(index => {
                    let newEmoji = getRandomEmoji();
                    if (newEmoji) {
                        emojis[index] = newEmoji;
                        setSquareContent(squares[index], newEmoji);
                        squares[index].style.setProperty('--bg-color', emojiColors[newEmoji]);
                    }
                });
            });
            matches = findAllMatches();
        }
    }
   
   function getRandomEmoji() {
       const rand = Math.floor(Math.random() * currentEmojis.length);
       return currentEmojis[rand];
   }

    function setSquareContent(square, emoji) {
        if (!square) return;
        if (emoji === dogEmoji) {
            square.innerHTML = '<img src="dog.png" alt="Dog" class="dog-image">';
        } else {
            square.innerHTML = '';
            square.textContent = emoji;
        }
    }

    function clearSquareContent(square) {
        if (!square) return;
        square.innerHTML = '';
        square.textContent = '';
        square.style.setProperty('--bg-color', 'transparent');
    }

    function addEventListeners() {
        squares.forEach(square => {
            square.addEventListener('dragstart', dragStart);
            square.addEventListener('dragover', dragOver);
            square.addEventListener('drop', dragDrop);
            square.addEventListener('dragend', dragEnd);
            square.addEventListener('click', handleSquareClick);
        });
        squares.forEach(square => {
            square.addEventListener('touchstart', handleTouchStart, { passive: true });
            square.addEventListener('touchend', handleTouchEnd, { passive: true });
        });
        restartButton.addEventListener('click', resetGame);
        infoButton.addEventListener('click', showInfo);
        document.addEventListener('mousedown', resetIdleTimer);
        document.addEventListener('touchstart', resetIdleTimer);
    }

    function dragStart(e) {
        dragStartIndex = parseInt(this.id);
        this.classList.add('dragging');
    }

    function dragOver(e) {
        e.preventDefault();
    }

    function dragDrop(e) {
        dragEndIndex = parseInt(this.id);
        if (isAdjacent(dragStartIndex, dragEndIndex)) {
            swapEmojis(dragStartIndex, dragEndIndex);
            const initialMatches = findMatchesUserAction();
            if (initialMatches.length > 0) {
                checkMatches(true);
            } else {
                swapEmojis(dragEndIndex, dragStartIndex);
            }
        }
    }

    function dragEnd() {
        squares.forEach(square => square.classList.remove('dragging'));
    }

    function handleTouchStart(e) {
        if (e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchStartIdLocal = parseInt(this.id);
        }
    }

    function handleTouchEnd(e) {
        if (touchStartX === null || touchStartY === null) return;
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const threshold = 24;
        let dragEndIndexLocal = touchStartIdLocal;

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > threshold) {
                dragEndIndexLocal = touchStartIdLocal + 1;
            } else if (deltaX < -threshold) {
                dragEndIndexLocal = touchStartIdLocal - 1;
            }
        } else {
            if (deltaY > threshold) {
                dragEndIndexLocal = touchStartIdLocal + width;
            } else if (deltaY < -threshold) {
                dragEndIndexLocal = touchStartIdLocal - width;
            }
        }

        if (isAdjacent(touchStartIdLocal, dragEndIndexLocal) && dragEndIndexLocal >= 0 && dragEndIndexLocal < width * width) {
            swapEmojis(touchStartIdLocal, dragEndIndexLocal);
            const initialMatches = findMatchesUserAction();
            if (initialMatches.length > 0) {
                checkMatches(true);
            } else {
                swapEmojis(dragEndIndexLocal, touchStartIdLocal);
            }
        }

        touchStartX = null;
        touchStartY = null;
        touchStartIdLocal = null;
    }

    function handleSquareClick(e) {
        const index = parseInt(this.id);
        if (powerUpActive && index === blinkingIndex && emojis[index] === bombEmoji) {
            triggerPowerUp(index);
        }
    }

    function isAdjacent(index1, index2) {
        const row1 = Math.floor(index1 / width);
        const col1 = index1 % width;
        const row2 = Math.floor(index2 / width);
        const col2 = index2 % width;
        const rowDiff = Math.abs(row1 - row2);
        const colDiff = Math.abs(col1 - col2);
        return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
    }

    function swapEmojis(index1, index2) {
        const tempEmoji = emojis[index1];
        emojis[index1] = emojis[index2];
        emojis[index2] = tempEmoji;
        setSquareContent(squares[index1], emojis[index1]);
        setSquareContent(squares[index2], emojis[index2]);
        squares[index1].style.setProperty('--bg-color', emojiColors[emojis[index1]]);
        squares[index2].style.setProperty('--bg-color', emojiColors[emojis[index2]]);
        updatePowerUpPosition(index1, index2);
    }

    function updatePowerUpPosition(oldIndex, newIndex) {
        if (powerUpActive) {
            if (oldIndex === blinkingIndex) {
                if (squares[blinkingIndex]) {
                    squares[blinkingIndex].classList.remove('blinking');
                }
                blinkingIndex = newIndex;
                if (squares[blinkingIndex]) {
                    squares[blinkingIndex].classList.add('blinking');
                }
            } else if (newIndex === blinkingIndex) {
                if (squares[blinkingIndex]) {
                    squares[blinkingIndex].classList.remove('blinking');
                }
                blinkingIndex = oldIndex;
                if (squares[blinkingIndex]) {
                    squares[blinkingIndex].classList.add('blinking');
                }
            }
        }
    }

    function findAllMatches() {
        const matches = [];
        for (let row = 0; row < width; row++) {
            for (let col = 0; col < width - 2; col++) {
                const idx = row * width + col;
                const first = emojis[idx];
                const second = emojis[idx + 1];
                const third = emojis[idx + 2];
                if (first === second && second === third && first !== '' && first !== bombEmoji) {
                    let match = [idx, idx + 1, idx + 2];
                    for (let k = col + 3; k < width; k++) {
                        const nextIdx = row * width + k;
                        if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                            match.push(nextIdx);
                        } else {
                            break;
                        }
                    }
                    matches.push(match);
                    col += match.length - 1;
                }
            }
        }

        for (let col = 0; col < width; col++) {
            for (let row = 0; row < width - 2; row++) {
                const idx = row * width + col;
                const first = emojis[idx];
                const second = emojis[idx + width];
                const third = emojis[idx + 2 * width];
                if (first === second && second === third && first !== '' && first !== bombEmoji) {
                    let match = [idx, idx + width, idx + 2 * width];
                    for (let k = row + 3; k < width; k++) {
                        const nextIdx = k * width + col;
                        if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                            match.push(nextIdx);
                        } else {
                            break;
                        }
                    }
                    matches.push(match);
                    row += match.length - 1;
                }
            }
        }
        return matches;
    }

    function findMatchesUserAction() {
        return findAllMatches();
    }

    async function checkMatches(isUserAction = false) {
        let matches = findAllMatches();
        let lastMatchIndex = null;
        for (let match of matches) {
            totalMatchesInCombo += 1;
            if (totalMatchesInCombo >= 2) {
                showCombo(totalMatchesInCombo);
            }
            const popupIndex = match[Math.floor(match.length / 2)];
            lastMatchIndex = popupIndex;
            const points = match.length * 10;
            score += points;
            scoreDisplay.textContent = score;
            createScorePopup(popupIndex, `+${points}`);
            const square = squares[popupIndex];
            if (square) {
                const rect = square.getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                createParticles(match.length * 10, emojiColors[emojis[popupIndex]], rect.left - gameRect.left + rect.width / 2, rect.top - gameRect.top + rect.height / 2);
            }
            for (let index of match) {
                let emoji = emojis[index];
                destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                emojisDestroyedSinceLastBomb += 1;
                await triggerExplosion(index);
                if (powerUpActive && index === blinkingIndex) {
                    if (squares[index]) {
                        squares[index].classList.remove('blinking');
                    }
                    powerUpActive = false;
                    blinkingIndex = null;
                }
            }
            if (emojisDestroyedSinceLastBomb >= 15) {
                emojisDestroyedSinceLastBomb = 0;
                activatePowerup();
            }
            if (score >= getTargetScore(level)) {
                await checkLevelUp();
            }
        }
        await fillEmptySpaces();
        matches = findAllMatches();
        if (matches.length > 0) {
            await checkMatches(false);
        }
        if (totalMatchesInCombo > 0 && lastMatchIndex !== null) {
            showMoveScore(totalMatchesInCombo * 10, lastMatchIndex);
        }
        checkEndGame();
    }

    function showMoveScore(totalScore, index) {
        const square = squares[index];
        if (!square) {
            console.warn(`showMoveScore: square at index ${index} is undefined`);
            return;
        }
        const rect = square.getBoundingClientRect();
        const gameRect = gameContainer.getBoundingClientRect();
        const x = rect.left - gameRect.left + rect.width / 2;
        const y = rect.top - gameRect.top + rect.height / 2;
        const moveScore = document.createElement('div');
        moveScore.classList.add('score-popup', 'move-score');
        moveScore.textContent = `+${totalScore}`;
        moveScore.style.left = `${x}px`;
        moveScore.style.top = `${y}px`;
        const isPurple = Math.random() < 0.5;
        if (isPurple) {
            moveScore.classList.add('move-score-purple');
        } else {
            moveScore.classList.add('move-score-green');
        }
        gameContainer.appendChild(moveScore);
        setTimeout(() => {
            moveScore.remove();
        }, 1500);
    }

    function fillEmptySpaces() {
        return new Promise(resolve => {
            for (let col = 0; col < width; col++) {
                let emptySpots = 0;
                for (let row = width - 1; row >= 0; row--) {
                    const idx = row * width + col;
                    if (emojis[idx] === '' || emojis[idx] === undefined) {
                        emptySpots++;
                    } else if (emptySpots > 0) {
                        const newIdx = (row + emptySpots) * width + col;
                        const movingEmoji = emojis[idx];
                        emojis[newIdx] = movingEmoji;
                        setSquareContent(squares[newIdx], movingEmoji);
                        squares[newIdx].style.setProperty('--bg-color', emojiColors[movingEmoji]);
                        emojis[idx] = '';
                        clearSquareContent(squares[idx]);
                        squares[newIdx].classList.add('fall');
                        setTimeout(() => {
                            squares[newIdx].classList.remove('fall');
                            if (powerUpActive && movingEmoji === bombEmoji) {
                                if (squares[blinkingIndex]) {
                                    squares[blinkingIndex].classList.remove('blinking');
                                }
                                blinkingIndex = newIdx;
                                if (squares[blinkingIndex]) {
                                    squares[blinkingIndex].classList.add('blinking');
                                }
                            }
                        }, 800);
                    }
                }
                for (let row = 0; row < emptySpots; row++) {
                    const idx = row * width + col;
                    const newEmoji = getRandomEmoji();
                    if (newEmoji) {
                        emojis[idx] = newEmoji;
                        setSquareContent(squares[idx], newEmoji);
                        squares[idx].style.setProperty('--bg-color', emojiColors[newEmoji]);
                        squares[idx].classList.add('fall');
                        setTimeout(() => {
                            squares[idx].classList.remove('fall');
                            if (powerUpActive && newEmoji === bombEmoji) {
                                if (blinkingIndex !== idx) {
                                    if (blinkingIndex !== null && squares[blinkingIndex]) {
                                        squares[blinkingIndex].classList.remove('blinking');
                                    }
                                    blinkingIndex = idx;
                                    if (squares[blinkingIndex]) {
                                        squares[blinkingIndex].classList.add('blinking');
                                    }
                                }
                            }
                        }, 800);
                    }
                }
            }
            setTimeout(() => {
                resolve();
            }, 800);
        });
    }

    function activatePowerup() {
        if (powerUpActive) return;
        const availableIndices = squares.map((_, idx) => idx).filter(idx => emojis[idx] !== bombEmoji && emojis[idx] !== dogEmoji);
        if (availableIndices.length === 0) return;
        blinkingIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
        emojis[blinkingIndex] = bombEmoji;
        setSquareContent(squares[blinkingIndex], bombEmoji);
        squares[blinkingIndex].style.setProperty('--bg-color', emojiColors[bombEmoji]);
        squares[blinkingIndex].classList.add('blinking');
        powerUpActive = true;
        emojisDestroyedSinceLastBomb = 0;
    }

    async function triggerPowerUp(index) {
        const row = Math.floor(index / width);
        const col = index % width;
        const indicesToDestroy = [];
        const directions = [
            { r: -1, c: 0 },
            { r: 1, c: 0 },
            { r: 0, c: -1 },
            { r: 0, c: 1 }
        ];
        for (let l = 1; l <= powerUpRange; l++) {
            directions.forEach(dir => {
                const newRow = row + dir.r * l;
                const newCol = col + dir.c * l;
                if (newRow >= 0 && newRow < width && newCol >= 0 && newCol < width) {
                    const idx = newRow * width + newCol;
                    if (emojis[idx] !== '') {
                        indicesToDestroy.push(idx);
                    }
                }
            });
        }
        indicesToDestroy.push(index);
        await animateExplosion(index, indicesToDestroy);
    }

    async function animateExplosion(centerIdx, indices) {
        powerUpActive = false;
        blinkingIndex = null;
        for (let i = 0; i < indices.length; i++) {
            const idx = indices[i];
            if (emojis[idx] !== '') {
                let emoji = emojis[idx];
                destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                score += 4;
                scoreDisplay.textContent = score;
                emojis[idx] = '';
                clearSquareContent(squares[idx]);
                squares[idx].style.removeProperty('--bg-color');
                createParticles(4, emojiColors[emoji], squares[idx].offsetLeft + squares[idx].offsetWidth / 2, squares[idx].offsetTop + squares[idx].offsetHeight / 2);
                await delay(160);
            }
        }
        if (squares[centerIdx]) {
            squares[centerIdx].classList.remove('blinking');
        }
        gameContainer.classList.add('vibrate');
        setTimeout(() => {
            gameContainer.classList.remove('vibrate');
        }, 800);
        await fillEmptySpaces();
        await checkMatches(false);
    }

    function createParticles(count, color, x, y) {
        const maxParticles = 112;
        const actualCount = Math.min(count, maxParticles);
        for (let i = 0; i < actualCount; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            const greenShades = ['#00FF00', '#32CD32', '#7CFC00', '#ADFF2F'];
            const purpleShades = ['#800080', '#DA70D6', '#BA55D3', '#9932CC'];
            const colorsPool = greenShades.concat(purpleShades);
            const randomColor = colorsPool[Math.floor(Math.random() * colorsPool.length)];
            particle.style.backgroundColor = randomColor;
            const size = Math.floor(Math.random() * 7) + 6;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * (grid.offsetWidth * 0.15);
            const tx = radius * Math.cos(angle);
            const ty = radius * Math.sin(angle);
            particle.style.setProperty('--tx', `${tx}px`);
            particle.style.setProperty('--ty', `${ty}px`);
            particlesContainer.appendChild(particle);
            setTimeout(() => {
                particle.remove();
            }, 960);
        }
    }

    function createScorePopup(index, text) {
        const popup = document.createElement('div');
        popup.classList.add('score-popup');
        const square = squares[index];
        if (!square) {
            console.warn(`createScorePopup: square at index ${index} is undefined`);
            return;
        }
        const rect = square.getBoundingClientRect();
        const gameRect = gameContainer.getBoundingClientRect();
        const left = rect.left - gameRect.left + rect.width / 2;
        const top = rect.top - gameRect.top + rect.height / 2;
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
        popup.textContent = text;
        popup.style.zIndex = '10';
        gameContainer.appendChild(popup);
        setTimeout(() => {
            popup.remove();
        }, 1500);
    }

    function showLevelUpMessage() {
        const message = document.createElement('div');
        message.classList.add('level-up-message');
        message.textContent = `Nivel ${level}`;
        document.body.appendChild(message);
        setTimeout(() => {
            message.remove();
        }, 1500);
    }

    async function checkLevelUp() {
        if (isLevelUpInProgress) return;
        isLevelUpInProgress = true;
        await destroyAllEmojisWithParticles();
        previousEmojis = currentEmojis.filter(emoji => emoji !== dogEmoji);
        setTimeout(() => {
            levelUp();
            showLevelUpMessage();
            isLevelUpInProgress = false;
        }, 240);
    }

    function levelUp() {
        level += 1;
        levelDisplay.textContent = level;
        updateTargetScore();
        setCurrentEmojis(true);
        powerUpRange = Math.min(6, powerUpRange + 1);
        resetGridForNewLevel();
    }

    async function destroyAllEmojisWithParticles() {
        const maxParticles = 8;
        let particlesCreated = 0;
        for (let i = 0; i < squares.length; i++) {
            if (emojis[i] !== '' && emojis[i] !== bombEmoji) {
                let emoji = emojis[i];
                destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                score += 2;
                scoreDisplay.textContent = score;
                emojis[i] = '';
                clearSquareContent(squares[i]);
                if (particlesCreated < maxParticles) {
                    const square = squares[i];
                    if (square) {
                        const rect = square.getBoundingClientRect();
                        const gameRect = gameContainer.getBoundingClientRect();
                        createParticles(1, emojiColors[emoji], rect.left - gameRect.left + rect.width / 2, rect.top - gameRect.top + rect.height / 2);
                        particlesCreated++;
                    }
                }
            }
        }
    }

    function showCombo(multiplier) {
        if (multiplier < 2) return;
        const comboText = document.getElementById('combo-text');
        comboText.textContent = `Combo x${multiplier}`;
        let color;
        if (multiplier <= 3) {
            color = '#FFD700';
        } else if (multiplier <= 10) {
            const progress = (multiplier - 3) / 7;
            color = interpolateColor('#FFD700', '#FFA500', progress);
        } else {
            const progress = Math.min((multiplier - 10) / 10, 1);
            color = interpolateColor('#FFA500', '#FF0000', progress);
        }
        comboText.style.color = color;
        comboText.style.opacity = '1';
        comboText.classList.add('show');
    }

    function interpolateColor(color1, color2, progress) {
        const r1 = parseInt(color1.slice(1, 3), 16);
        const g1 = parseInt(color1.slice(3, 5), 16);
        const b1 = parseInt(color1.slice(5, 7), 16);
        const r2 = parseInt(color2.slice(1, 3), 16);
        const g2 = parseInt(color2.slice(3, 5), 16);
        const b2 = parseInt(color2.slice(5, 7), 16);
        const r = Math.round(r1 + (r2 - r1) * progress);
        const g = Math.round(g1 + (g2 - g1) * progress);
        const b = Math.round(b1 + (b2 - b1) * progress);
        return `#${(r < 16 ? '0' : '') + r.toString(16)}${(g < 16 ? '0' : '') + g.toString(16)}${(b < 16 ? '0' : '') + b.toString(16)}`;
    }

    function interpolateColor(color1, color2, progress) {
        const r1 = parseInt(color1.slice(1, 3), 16);
        const g1 = parseInt(color1.slice(3, 5), 16);
        const b1 = parseInt(color1.slice(5, 7), 16);
        const r2 = parseInt(color2.slice(1, 3), 16);
        const g2 = parseInt(color2.slice(3, 5), 16);
        const b2 = parseInt(color2.slice(5, 7), 16);
        const r = Math.round(r1 + (r2 - r1) * progress);
        const g = Math.round(g1 + (g2 - g1) * progress);
        const b = Math.round(b1 + (b2 - b1) * progress);
        return `#${(r < 16 ? '0' : '') + r.toString(16)}${(g < 16 ? '0' : '') + g.toString(16)}${(b < 16 ? '0' : '') + b.toString(16)}`;
    }

    function hideCombo() {
        const comboText = document.getElementById('combo-text');
        comboText.style.opacity = '0';
        comboText.classList.remove('show');
    }

    function resetGridForNewLevel() {
        squares.forEach(square => {
            square.classList.remove('blinking', 'match', 'fall', 'hint');
            emojis[square.id] = '';
            clearSquareContent(square);
            square.style.removeProperty('--bg-color');
        });
        powerUpActive = false;
        blinkingIndex = null;
        fillBoard();
        stabilizeBoard();
    }

    function showInfo() {
        if (document.querySelector('.stats-popup')) return;
        const infoContainer = document.createElement('div');
        infoContainer.classList.add('stats-popup');
        const title = document.createElement('h2');
        title.textContent = 'ðŸ“Š EstadÃ­sticas';
        infoContainer.appendChild(title);
        const gamesPlayed = document.createElement('p');
        gamesPlayed.textContent = `ðŸŽ® Partidas jugadas: ${totalGamesPlayed}`;
        infoContainer.appendChild(gamesPlayed);
        const timePlayed = document.createElement('p');
        const totalMinutes = Math.floor(totalTimePlayed / 60000);
        timePlayed.textContent = `â±ï¸ Tiempo total jugado: ${totalMinutes} minutos`;
        infoContainer.appendChild(timePlayed);
        const emojiStatsTitle = document.createElement('h3');
        emojiStatsTitle.textContent = 'ðŸ¥‡ Top 10 emojis destruidos:';
        infoContainer.appendChild(emojiStatsTitle);
        const sortedEmojis = Object.entries(destroyedEmojis).sort((a, b) => b[1] - a[1]).slice(0, 10);
        const emojiList = document.createElement('ul');
        sortedEmojis.forEach(([emoji, count]) => {
            const listItem = document.createElement('li');
            if (emoji === dogEmoji) {
                listItem.innerHTML = `<img src="dog.png" alt="Dog" style="width: 20px; height: 20px; vertical-align: middle;"> - ${count}`;
            } else {
                listItem.textContent = `${emoji} - ${count}`;
            }
            emojiList.appendChild(listItem);
        });
        infoContainer.appendChild(emojiList);
        const closeButton = document.createElement('button');
        closeButton.textContent = 'ðŸ”š Cerrar';
        closeButton.addEventListener('click', () => {
            infoContainer.remove();
        });
        infoContainer.appendChild(closeButton);
        document.body.appendChild(infoContainer);
    }

    function resetIdleTimer() {
        totalMatchesInCombo = 0;
        hideCombo();
    }

    function updateTargetScore() {
        const target = getTargetScore(level);
        targetScoreDisplay.textContent = target;
    }

    setInterval(() => {
        if (totalMatchesInCombo === 0) {
            hintPossibleMatch();
        }
    }, 800);

    function hintPossibleMatch() {
        const possibleMoves = findPossibleMoves();
        if (possibleMoves.length > 0) {
            const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            randomMove.forEach(index => {
                if (squares[index]) {
                    squares[index].classList.add('hint');
                    setTimeout(() => {
                        squares[index].classList.remove('hint');
                    }, 640);
                }
            });
        }
    }

    function checkEndGame() {
        const hasBomb = emojis.includes(bombEmoji);
        if (hasBomb) return;
        const possibleMoves = findPossibleMoves();
        if (possibleMoves.length === 0) {
            gameOverDisplay.style.display = 'block';
            squares.forEach(square => {
                square.removeEventListener('dragstart', dragStart);
                square.removeEventListener('dragover', dragOver);
                square.removeEventListener('drop', dragDrop);
                square.removeEventListener('dragend', dragEnd);
                square.removeEventListener('click', handleSquareClick);
                square.removeEventListener('touchstart', handleTouchStart);
                square.removeEventListener('touchend', handleTouchEnd);
            });
        }
    }

    function findPossibleMoves() {
        let possibleMoves = [];
        for (let i = 0; i < width * width; i++) {
            const row = Math.floor(i / width);
            const col = i % width;
            if (col < width - 1) {
                swapEmojis(i, i + 1);
                if (findAllMatches().length > 0) {
                    possibleMoves.push([i, i + 1]);
                }
                swapEmojis(i, i + 1);
            }
            if (row < width - 1) {
                swapEmojis(i, i + width);
                if (findAllMatches().length > 0) {
                    possibleMoves.push([i, i + width]);
                }
                swapEmojis(i, i + width);
            }
        }
        return possibleMoves;
    }

    async function triggerExplosion(index) {
        const square = squares[index];
        if (!square) {
            console.warn(`triggerExplosion: square at index ${index} is undefined`);
            return;
        }
        square.classList.add('explode');
        await delay(160);
        emojis[index] = '';
        clearSquareContent(square);
        square.classList.remove('explode');
    }

    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function checkMatches(isUserAction = false) {
        let matches = findAllMatches();
        let lastMatchIndex = null;
        for (let match of matches) {
            totalMatchesInCombo += 1;
            if (totalMatchesInCombo >= 2) {
                showCombo(totalMatchesInCombo);
            }
            const popupIndex = match[Math.floor(match.length / 2)];
            lastMatchIndex = popupIndex;
            const points = match.length * 10;
            score += points;
            scoreDisplay.textContent = score;
            createScorePopup(popupIndex, `+${points}`);
            const square = squares[popupIndex];
            if (square) {
                const rect = square.getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                createParticles(match.length * 10, emojiColors[emojis[popupIndex]], rect.left - gameRect.left + rect.width / 2, rect.top - gameRect.top + rect.height / 2);
            }
            for (let index of match) {
                let emoji = emojis[index];
                destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                emojisDestroyedSinceLastBomb += 1;
                await triggerExplosion(index);
                if (powerUpActive && index === blinkingIndex) {
                    if (squares[index]) {
                        squares[index].classList.remove('blinking');
                    }
                    powerUpActive = false;
                    blinkingIndex = null;
                }
            }
            if (emojisDestroyedSinceLastBomb >= 15) {
                emojisDestroyedSinceLastBomb = 0;
                activatePowerup();
            }
            if (score >= getTargetScore(level)) {
                await checkLevelUp();
            }
        }
        await fillEmptySpaces();
        matches = findAllMatches();
        if (matches.length > 0) {
            await checkMatches(false);
        }
        if (totalMatchesInCombo > 0 && lastMatchIndex !== null) {
            showMoveScore(totalMatchesInCombo * 10, lastMatchIndex);
        }
        checkEndGame();
    }

    function resetGame() {
        totalGamesPlayed += 1;
        totalTimePlayed += Date.now() - gameStartTime;
        saveStatistics();
        score = 0;
        level = 1;
        powerUpRange = 1;
        emojisDestroyedSinceLastBomb = 0;
        powerUpActive = false;
        blinkingIndex = null;
        isLevelUpInProgress = false;
        totalMatchesInCombo = 0;
        scoreDisplay.textContent = score;
        levelDisplay.textContent = level;
        highScoreDisplay.textContent = highScore;
        updateTargetScore();
        gameOverDisplay.style.display = 'none';
        squares.forEach(square => {
            square.classList.remove('blinking', 'match', 'fall', 'hint');
            emojis[square.id] = '';
            clearSquareContent(square);
            square.style.removeProperty('--bg-color');
        });
        currentEmojis = [];
        previousEmojis = [];
        setCurrentEmojis(true);
        gameStartTime = Date.now();
        const randomColor = softColors[Math.floor(Math.random() * softColors.length)];
        grid.style.backgroundColor = randomColor;
        fillBoard();
        stabilizeBoard();
        updateTargetScore();
    }

    initializeGame();
});
</script>



</body>
</html>