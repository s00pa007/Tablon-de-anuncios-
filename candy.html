<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Match3 🎉</title>
    <style>
        /* Reset de Estilos */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Estilos del Body */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #f0f0f0; /* Color de fondo suave */
        }

        /* Contenedor del Juego */
        .game-container {
            background: linear-gradient(135deg, #ff7e5f, #feb47b); /* Gradiente coral a naranja */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            text-align: center;
            position: relative;
            width: 90vw; /* Ancho expandido al 90% del viewport */
            max-width: 1200px; /* Máximo ancho para pantallas grandes */
            transition: transform 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        /* Estadísticas */
        .stats {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 10px;
            width: 100%;
        }

        .stat {
            font-size: 1.2rem;
            color: #ffffff;
            position: relative;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat .counter {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ff4081;
        }

        /* Cuadrícula de Juego */
        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            justify-content: center;
            align-content: start;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 10px;
            transition: all 0.3s ease-in-out;
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 90vw; /* Aumentado de 600px a 90vw para hacer el área de juego más grande */
            height: auto;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .grid div {
            background-color: var(--bg-color, rgba(224, 247, 250, 0.9));
            border: 1px solid #00838f;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 2rem; /* Aumentado para mejorar la visibilidad */
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            width: 100%;
            aspect-ratio: 1 / 1;
        }

.grid div img {
    width: 98%; /* Ajustado para que la imagen sea un 10% más grande */
    height: 98%;
    object-fit: contain;
}
        

        .grid div:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0, 131, 143, 0.6);
            background-color: var(--bg-color, rgba(178, 235, 242, 0.9));
        }

        /* Fin del Juego */
        .game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: #d32f2f;
            text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(5deg); }
            50% { transform: translate(-50%, -50%) rotate(-5deg); }
            75% { transform: translate(-50%, -50%) rotate(5deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }

        /* Animaciones de Eliminación y Explosión */
        .match {
            animation: matchAnimation 0.5s forwards;
        }

        @keyframes matchAnimation {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 1;
            }
            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        /* Partículas */
        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            border-radius: 15px;
            z-index: 2;
        }

        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: #ff4081;
            border-radius: 50%;
            opacity: 0;
            animation: particle 1s forwards;
        }

        @keyframes particle {
            from {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            to {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(2);
            }
        }

        /* Animación de Caída */
        .fall {
            animation: fallAnimation 0.3s forwards;
        }

        @keyframes fallAnimation {
            0% {
                transform: translateY(-100%);
            }
            100% {
                transform: translateY(0);
            }
        }

        /* Parpadeo para el Power-Up (Bomba) */
        .blinking {
            animation: blink 0.8s infinite;
            border: 2px solid gold;
            border-radius: 50%;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Efecto de vibración en el Power-Up */
        .vibrate {
            animation: vibrate 0.5s;
        }

        @keyframes vibrate {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        /* Parpadeo de posibles matches */
        .hint {
            animation: hintAnimation 1s infinite;
        }

        @keyframes hintAnimation {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Popup de Puntuación */
        .score-popup {
            position: absolute;
            font-size: 1rem;
            color: #ffeb3b;
            animation: popUp 1s forwards;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 5px rgba(0,0,0,0.5);
            z-index: 15;
        }

        @keyframes popUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            50% {
                opacity: 1;
                transform: translateY(-20px) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(2);
            }
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .controls button {
            background-color: #ff4081;
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls button:hover {
            background-color: #e91e63;
            transform: translateY(-2px);
        }

        /* Ventana de Estadísticas */
        .stats-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            font-size: 0.9rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .stats-popup h2, .stats-popup h3 {
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 10px;
        }

        .stats-popup ul {
            list-style-type: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .stats-popup li {
            margin: 5px 0;
            text-align: center;
        }

        .stats-popup button {
            margin-top: 20px;
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
            background-color: #ff4081;
            border: none;
            color: #fff;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .stats-popup button:hover {
            background-color: #e91e63;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .stats .stat {
                font-size: 1.2rem;
            }
            .stats .counter {
                font-size: 1rem;
            }
            .game-over {
                font-size: 2rem;
            }
            .score-popup {
                font-size: 0.8rem;
            }
            .controls button {
                padding: 8px 16px;
                font-size: 1.2rem;
            }
            .stats-popup {
                font-size: 0.8rem;
            }
            .stats-popup h2, .stats-popup h3 {
                font-size: 1rem;
            }
            .stats-popup p, .stats-popup ul, .stats-popup li {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Estadísticas del Juego -->
        <div class="stats">
            <div class="stat">🔄 <span class="counter" id="matches-made">0</span></div>
            <div class="stat">🎯 <span class="counter" id="target-matches">5</span></div>
            <div class="stat">📈 <span class="counter" id="level-indicator">1</span></div>
            <div class="stat">🏆 <span class="counter" id="high-score-value">0</span></div>
        </div>

        <!-- Cuadrícula del Juego -->
        <div class="grid"></div>

        <!-- Pantalla de Fin de Juego -->
        <div id="game-over" class="game-over">💥 ¡Juego Terminado! 💥</div>

        <!-- Controles del Juego -->
        <div class="controls">
            <button id="restart" title="Reiniciar Juego">🔄</button>
            <button id="info" title="Información">ℹ️</button>
        </div>

        <!-- Contenedor de Partículas -->
        <div class="particles" id="particles"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const grid = document.querySelector('.grid');
            const width = 8; // Tamaño de la cuadrícula (8x8)

            // Lista reducida de emojis para simplificar
            const allEmojis = [
'😀','😃','😄','😁','😆','😅','😂','🤣','😊','😇',
'🙂','🙃','😉','😌','😍','🥰','😘','😗','😙','😚',
'😋','😛','😝','😜','🤪','🤨','🧐','🤓','😎','🥸',
'🤩','🥳','😏','😒','😞','😔','😟','😕','🙁','☹️',
'😣','😖','😫','😩','🥺','😢','😭','😤','😠','😡',
'🤬','😳','🥵','🥶','😱','😨','😰','😥','😓','🤗',
'🤔','🤭','🤫','🤥','😶','😐','😑','😬','🙄','😯',
'😦','😧','😮','😲','🥱','😴','🤤','😪','😵','🤐',
'🥴','🤢','🤮','🤧','😷','🤒','🤕','🤑','🤠','😈',
'👿','👹','👺','🤡','💩','👻','💀','☠️','👽','👾',
'🤖','🎃','😺','😸','😹','😻','😼','😽','🙀','😿',
'😾',
// Personas y profesiones
'🧑','👨','👩','👶','👧','👦','👩‍🦰','👨‍🦰','👱‍♀️','👱‍♂️',
'👩‍🦱','👨‍🦱','👩‍🦳','👨‍🦳','👩‍🦲','👨‍🦲','🧓','👴','👵','👲',
'👳‍♀️','👳‍♂️','👮‍♀️','👮‍♂️','🕵️‍♀️','🕵️‍♂️','💂‍♀️','💂‍♂️','👷‍♀️','👷‍♂️',
'🤴','👸','👼','🤰','🤱','👩‍⚕️','👨‍⚕️','👩‍🎓','👨‍🎓','👩‍🏫',
'👨‍🏫','👩‍⚖️','👨‍⚖️','👩‍🌾','👨‍🌾','👩‍🍳','👨‍🍳','👩‍🔧','👨‍🔧','👩‍🏭',
'👨‍🏭','👩‍💼','👨‍💼','👩‍🔬','👨‍🔬','👩‍💻','👨‍💻','👩‍🎤','👨‍🎤','👩‍🎨',
'👨‍🎨','👩‍✈️','👨‍✈️','👩‍🚀','👨‍🚀','👩‍🚒','👨‍🚒','🧑‍🚒',
// Animales y naturaleza
'🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐨','🐯',
'🦁','🐮','🐷','🐽','🐸','🐵','🙈','🙉','🙊','🐒',
'🐔','🐧','🐦','🐤','🐣','🐥','🦆','🦅','🦉','🦇',
'🐺','🐗','🐴','🦄','🐝','🐛','🦋','🐌','🐚','🐞',
'🐜','🕷️','🕸️','🦂','🐢','🐍','🦎','🐙','🦑','🦐',
'🦀','🐡','🐠','🐟','🐬','🐳','🐋','🦈','🐊','🐅',
'🐆','🦓','🦍','🦧','🐘','🦏','🐪','🐫','🦒','🐃',
'🐂','🐄','🐎','🐖','🐏','🐑','🐐','🦌','🐕','🐩',
'🐈','🐓','🦃','🕊️','🐇','🐁','🐀','🐿️','🦔',
// Comida y bebidas
'🍏','🍎','🍐','🍊','🍋','🍌','🍉','🍇','🍓','🫐',
'🍈','🍒','🍑','🥭','🍍','🥥','🥝','🍅','🍆','🥑',
'🥦','🥬','🥒','🌶️','🫑','🌽','🥕','🫒','🧄','🧅',
'🍄','🥜','🌰','🍞','🥐','🥖','🥨','🥯','🥞','🧇',
'🧀','🍖','🍗','🥩','🥓','🍔','🍟','🍕','🌭','🥪',
'🌮','🌯','🥙','🧆','🥚','🍳','🧈','🥘','🍲','🥣',
'🥗','🍿','🧂','🥫','🍱','🍘','🍙','🍚','🍛','🍜',
'🍝','🍠','🍢','🍣','🍤','🍥','🥮','🍡','🥟','🥠',
'🥡','🦪','🍦','🍧','🍨','🍩','🍪','🎂','🍰','🧁',
'🥧','🍫','🍬','🍭','🍮','🍯','🍼','🥛','☕','🍵',
'🍶','🍾','🍷','🍸','🍹','🥂','🍺','🍻','🥃','🥤',
'🧋','🧃','🧉','🧊',
// Actividades
'⚽','🏀','🏈','⚾','🥎','🎾','🏐','🏉','🎱','🏓',
'🏸','🥅','🏒','🏑','🥍','🏏','🪀','🥏','🎯','🪁',
'🎳','🎮','🕹️','🎰','🎲','♟️','🎭','🎨','🎤','🎧',
'🎼','🎹','🥁','🎷','🎺','🎸','🪕','🎻','🪗','🎬',
'🧩','🧸',
// Viajes y lugares
'🚗','🚕','🚙','🚌','🚎','🏎️','🚓','🚑','🚒','🚐',
'🚚','🚛','🚜','🛴','🚲','🛵','🏍️','🛺','🚨','🚔',
'✈️','🛩️','🛫','🛬','🪂','💺','🚁','🛶','⛵','🚤',
'🛥️','🚢','⚓','⛴️','🪝','🚧','🗺️','🧭','🏞️','🏕️',
'🏖️','🏜️','🏝️','🏟️','🏛️','🏗️','🧱','🪨','🪵','🪴',
'🌋','🗻','🏔️','⛰️',
// Objetos
'⌚','📱','📲','💻','⌨️','🖥️','🖨️','🖱️','🖲️','💽',
'💾','💿','📀','📼','📷','📸','📹','🎥','📽️','🎞️',
'📞','☎️','📟','📠','🔋','🔌','💡','🔦','🕯️','🪔',
'🧯','💰','🪙','💴','💵','💶','💷','💸','💳','🧾',
'💎','⚖️','🔧','🔨','⚒️','🛠️','⛏️','🔩','⚙️','🗜️',
'⚗️','🧪','🧫','🧬','🔬','🔭','📡','💉','🩸','💊',
'🩹','🩺','🚪','🛏️','🛋️','🪑','🚽','🚿','🛁','🪠',
'🧴','🧷','🧹','🧺','🧻','🪣','🪤','🧼','🪒','🧽',
'🛒','🚬','⚰️','⚱️','🗿','🪆','🛍️','🧳','👓',
'🕶️','🥽','🥼','🦺','👔','👕','👖','🧣','🧤','🧥',
'🧦','👗','👘','👙','👚','👛','👜','👝','🎒','🩴',
'👞','👟','🥾','🥿','👠','👡','🩰','👢','👑','👒',
'🎩','🎓','🧢','⛑️','📿','💄','💍','💎','🔇','🔈',
'🔉','🔊','📢','📣','📯','🔔','🔕','🎼','🎵','🎶',
'🏧','🚮','🚰','♿','🚹','🚺','🚻','🚼','🚾','🛂',
'🛃','🛄','🛅','⚠️','🚸','⛔','🚫','🚳','🚭','❌',
'⭕','✅','☑️','✔️','❎','➕','➖','➗','✖️','💱',
'💲','⚕️','♻️','📛','🔰','🆗','🆙','🆒','🆕','🆓',
'🆖','🅰️','🅱️','🆎','🆑','🅾️','🆘','🛑','‼️','⁉️',
'❓','❔','❕','❗','🔅','🔆','🔱','⚜️',
// Banderas
'🏳️','🏴','🏁','🚩','🏳️‍🌈','🏳️‍⚧️','🇦🇫','🇦🇱','🇩🇿','🇦🇸',
'🇦🇩','🇦🇴','🇦🇮','🇦🇶','🇦🇬','🇦🇷','🇦🇲','🇦🇼','🇦🇺','🇦🇹',
'🇦🇿','🇧🇸','🇧🇭','🇧🇩','🇧🇧','🇧🇾','🇧🇪','🇧🇿','🇧🇯','🇧🇲',
'🇧🇹','🇧🇴','🇧🇦','🇧🇼','🇧🇷','🇮🇴','🇻🇬','🇧🇳','🇧🇬','🇧🇫',
'🇧🇮','🇨🇻','🇰🇭','🇨🇲','🇨🇦','🇮🇨','🇰🇾','🇨🇫','🇹🇩','🇨🇱',
'🇨🇳','🇨🇽','🇨🇨','🇨🇴','🇰🇲','🇨🇬','🇨🇩','🇨🇰','🇨🇷','🇨🇮',
'🇭🇷','🇨🇺','🇨🇾','🇨🇿','🇩🇰','🇩🇯','🇩🇲','🇩🇴','🇪🇨','🇪🇬',
'🇸🇻','🇬🇶','🇪🇷','🇪🇪','🇪🇹','🇫🇯','🇫🇮','🇫🇷','🇬🇫','🇵🇫',
'🇹🇫','🇬🇦','🇬🇲','🇬🇪','🇩🇪','🇬🇭','🇬🇮','🇬🇷','🇬🇱','🇬🇩',
'🇬🇵','🇬🇺','🇬🇹','🇬🇬','🇬🇳','🇬🇼','🇬🇾','🇭🇹','🇭🇳','🇭🇰',
'🇭🇺','🇮🇸','🇮🇳','🇮🇩','🇮🇷','🇮🇶','🇮🇪','🇮🇱','🇮🇹','🇯🇲',
'🇯🇵','🇯🇪','🇯🇴','🇰🇿','🇰🇪','🇰🇮','🇽🇰','🇰🇼','🇰🇬','🇱🇦',
'🇱🇻','🇱🇧','🇱🇸','🇱🇷','🇱🇾','🇱🇮','🇱🇹','🇱🇺','🇲🇴','🇲🇰',
'🇲🇬','🇲🇼','🇲🇾','🇲🇻','🇲🇱','🇲🇹','🇲🇭','🇲🇶','🇲🇷','🇲🇺',
'🇾🇹','🇲🇽','🇫🇲','🇲🇩','🇲🇨','🇲🇳','🇲🇪','🇲🇸','🇲🇦','🇲🇿',
'🇲🇲','🇳🇦','🇳🇷','🇳🇵','🇳🇱','🇳🇨','🇳🇿','🇳🇮','🇳🇪','🇳🇬',
'🇳🇺','🇳🇫','🇰🇵','🇳🇴','🇴🇲','🇵🇰','🇵🇼','🇵🇸','🇵🇦','🇵🇬',
'🇵🇾','🇵🇪','🇵🇭','🇵🇱','🇵🇹','🇵🇷','🇶🇦','🇷🇴','🇷🇺','🇷🇼',
'🇧🇱','🇸🇭','🇰🇳','🇱🇨','🇵🇲','🇻🇨','🇼🇸','🇸🇲','🇸🇹','🇸🇦',
'🇸🇳','🇷🇸','🇸🇨','🇸🇱','🇸🇬','🇸🇰','🇸🇮','🇸🇧','🇸🇴','🇿🇦',
'🇰🇷','🇸🇸','🇪🇸','🇱🇰','🇸🇩','🇸🇷','🇸🇿','🇸🇪','🇨🇭','🇸🇾',
'🇹🇼','🇹🇯','🇹🇿','🇹🇭','🇹🇱','🇹🇬','🇹🇰','🇹🇴','🇹🇹','🇹🇳',
'🇹🇷','🇹🇲','🇹🇨','🇺🇬','🇺🇦','🇦🇪','🇬🇧','🇺🇸','🇺🇾','🇺🇿',
'🇻🇺','🇻🇦','🇻🇪','🇻🇳','🇼🇫','🇪🇭','🇾🇪','🇿🇲','🇿🇼',
// Otros emojis populares
'🎉','🎊','🎈','🎂','🍰','🍦','🍩','🍪','🍫','🍬',
'🍭','🍮','🎁','🎀','🎗️','🎟️','🎫','🎖️','🏆','🥇',
'🥈','🥉','⚽️','🏀','🏈','⚾️','🎾','🏐','🏉','🎱',
'🏓','🏸','🥅','🏒','🏑','🥍','🏏','🪀','🥏','🎯',
'🪁','🎳','🎮','🕹️','🎰','🎲','♟️','🎭','🎨','🎤',
'🎧','🎼','🎹','🥁','🎷','🎺','🎸','🪕','🎻','🪗',
'🎬','🧩','🧸',
];

            const bombEmoji = '💣';
            const dogEmoji = 'dog'; // Cadena específica para identificar al perro
            let emojis = [];
            const squares = [];
            let matchesMade = 0;
            let targetMatches = 5;
            let level = 1;
            let highScore = 0;
            let destroyedEmojis = {};
            let totalGamesPlayed = 0;
            let totalTimePlayed = 0;
            let gameStartTime;
            let powerUpActive = false;
            let destroyedEmojisCount = 0;
            let blinkingIndex = null;
            let lastUserActionTime = Date.now();

            // Elementos del DOM
            const gameOverDisplay = document.getElementById('game-over');
            const matchesDisplay = document.getElementById('matches-made');
            const levelDisplay = document.getElementById('level-indicator');
            const highScoreDisplay = document.getElementById('high-score-value');
            const targetMatchesDisplay = document.getElementById('target-matches');
            const restartButton = document.getElementById('restart');
            const infoButton = document.getElementById('info');
            const particlesContainer = document.getElementById('particles');
            const gameContainer = document.querySelector('.game-container');

            let dragStartIndex;
            let dragEndIndex;
            let touchStartX = null;
            let touchStartY = null;
            let touchStartIdLocal = null;
            let emojiColors = {};

            // Asignar colores a los emojis para mejorar la visualización
            function assignColorsToEmojis() {
                const colors = [
                    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
                    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
                    '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
                    '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080',
                    '#ffffff', '#000000'
                ];
                let colorIndex = 0;
                allEmojis.forEach(emoji => {
                    emojiColors[emoji] = colors[colorIndex % colors.length];
                    colorIndex++;
                });
                emojiColors[bombEmoji] = '#000'; // Color especial para la bomba
                emojiColors[dogEmoji] = '#ff9900'; // Color especial para el perro
            }

            assignColorsToEmojis();

            // Inicializar el juego
            function initializeGame() {
                loadHighScore();
                loadStatistics();
                setCurrentEmojis();
                createBoard();
                gameStartTime = Date.now();
            }

            // Cargar el puntaje más alto desde el almacenamiento local
            function loadHighScore() {
                const storedHighScore = localStorage.getItem('highMatches');
                if (storedHighScore) {
                    highScore = parseInt(storedHighScore);
                    highScoreDisplay.textContent = highScore;
                }
            }

            // Actualizar el puntaje más alto si es necesario
            function updateHighScore() {
                if (matchesMade > highScore) {
                    highScore = matchesMade;
                    highScoreDisplay.textContent = highScore;
                    localStorage.setItem('highMatches', highScore);
                }
            }

            // Cargar estadísticas desde el almacenamiento local
            function loadStatistics() {
                const storedGamesPlayed = localStorage.getItem('gamesPlayed');
                if (storedGamesPlayed) {
                    totalGamesPlayed = parseInt(storedGamesPlayed);
                }
                const storedTimePlayed = localStorage.getItem('timePlayed');
                if (storedTimePlayed) {
                    totalTimePlayed = parseInt(storedTimePlayed);
                }
                const storedDestroyedEmojis = localStorage.getItem('destroyedEmojis');
                if (storedDestroyedEmojis) {
                    destroyedEmojis = JSON.parse(storedDestroyedEmojis);
                } else {
                    destroyedEmojis = {};
                }
            }

            // Guardar estadísticas en el almacenamiento local
            function saveStatistics() {
                localStorage.setItem('gamesPlayed', totalGamesPlayed);
                localStorage.setItem('timePlayed', totalTimePlayed);
                localStorage.setItem('destroyedEmojis', JSON.stringify(destroyedEmojis));
            }

            // Configurar la lista actual de emojis basados en el nivel
            function setCurrentEmojis() {
                if (level === 1) {
                    currentEmojis = getRandomUniqueEmojis(allEmojis, 4); // Inicialmente 4 emojis
                    if (!currentEmojis.includes(dogEmoji)) {
                        currentEmojis.push(dogEmoji);
                    }
                } else {
                    // Cada nivel añade un emoji nuevo
                    const newEmoji = getNewEmoji();
                    if (newEmoji) {
                        currentEmojis.push(newEmoji);
                    }

                    // Cada dos niveles a partir del nivel 3, elimina un emoji antiguo (excepto el perro)
                    if (level >= 3 && level % 2 === 1) {
                        removeOldEmoji();
                    }
                }
            }

            // Obtener emojis únicos aleatorios
            function getRandomUniqueEmojis(array, number) {
                const filteredArray = array.filter(emoji => emoji !== bombEmoji && emoji !== dogEmoji);
                const shuffled = filteredArray.slice().sort(() => 0.5 - Math.random());
                return shuffled.slice(0, number);
            }

            // Obtener un nuevo emoji para agregar
            function getNewEmoji() {
                const availableEmojis = allEmojis.filter(emoji => !currentEmojis.includes(emoji) && emoji !== bombEmoji && emoji !== dogEmoji);
                if (availableEmojis.length === 0) return null;
                const randomIndex = Math.floor(Math.random() * availableEmojis.length);
                return availableEmojis[randomIndex];
            }

            // Remover un emoji antiguo (excepto el perro)
            function removeOldEmoji() {
                const removableEmojis = currentEmojis.filter(emoji => emoji !== dogEmoji);
                if (removableEmojis.length === 0) return;
                const emojiToRemove = removableEmojis[Math.floor(Math.random() * removableEmojis.length)];
                const removeIndex = currentEmojis.indexOf(emojiToRemove);
                if (removeIndex !== -1) {
                    currentEmojis.splice(removeIndex, 1);
                }
            }

            // Crear el tablero de juego
            function createBoard() {
                grid.innerHTML = '';
                squares.length = 0;
                for (let i = 0; i < width * width; i++) {
                    const square = document.createElement('div');
                    square.setAttribute('draggable', true);
                    square.setAttribute('id', i);
                    grid.appendChild(square);
                    squares.push(square);
                }
                fillBoard();
                addEventListeners();
            }

            // Rellenar el tablero con emojis aleatorios y estabilizarlo
            function fillBoard() {
                for (let i = 0; i < squares.length; i++) {
                    if (emojis[i] === undefined || emojis[i] === '') {
                        let randomEmoji = getRandomEmoji();
                        emojis[i] = randomEmoji;
                        setSquareContent(squares[i], randomEmoji);
                        squares[i].style.setProperty('--bg-color', emojiColors[randomEmoji]);
                    }
                }
                stabilizeBoard();
            }

            // Asegurar que no haya matches al inicio
            function stabilizeBoard() {
                let matches = findAllMatches();
                while (matches.length > 0) {
                    matches.forEach(match => {
                        match.forEach(index => {
                            let newEmoji = getRandomEmoji();
                            emojis[index] = newEmoji;
                            setSquareContent(squares[index], newEmoji);
                            squares[index].style.setProperty('--bg-color', emojiColors[newEmoji]);
                        });
                    });
                    matches = findAllMatches();
                }
            }

            // Obtener un emoji aleatorio de la lista actual
            function getRandomEmoji() {
                const rand = Math.floor(Math.random() * currentEmojis.length);
                return currentEmojis[rand];
            }

            // Establecer el contenido de una celda
            function setSquareContent(square, emoji) {
                if (emoji === dogEmoji) {
                    square.innerHTML = '<img src="Dog.png" alt="Dog">'; // Asegúrate de que Dog.png esté en la ruta correcta
                } else {
                    square.innerHTML = '';
                    square.textContent = emoji;
                }
            }

            // Limpiar el contenido de una celda
            function clearSquareContent(square) {
                square.innerHTML = '';
                square.textContent = '';
            }

            // Agregar eventos a las celdas y controles
            function addEventListeners() {
                squares.forEach(square => {
                    square.addEventListener('dragstart', dragStart);
                    square.addEventListener('dragover', dragOver);
                    square.addEventListener('drop', dragDrop);
                    square.addEventListener('dragend', dragEnd);
                    square.addEventListener('click', handleSquareClick);
                });
                squares.forEach(square => {
                    square.addEventListener('touchstart', handleTouchStart, { passive: true });
                    square.addEventListener('touchend', handleTouchEnd, { passive: true });
                });
                restartButton.addEventListener('click', resetGame);
                infoButton.addEventListener('click', showInfo);
                document.addEventListener('mousedown', resetIdleTimer);
                document.addEventListener('touchstart', resetIdleTimer);
            }

            // Manejo de eventos de arrastrar y soltar
            function dragStart(e) {
                dragStartIndex = parseInt(this.id);
                this.classList.add('dragging');
            }

            function dragOver(e) {
                e.preventDefault();
            }

            function dragDrop(e) {
                dragEndIndex = parseInt(this.id);
                if (isAdjacent(dragStartIndex, dragEndIndex)) {
                    swapEmojis(dragStartIndex, dragEndIndex);
                    if (findMatchesUserAction().length > 0) {
                        checkMatches(true);
                    } else {
                        swapEmojis(dragEndIndex, dragStartIndex);
                    }
                }
            }

            function dragEnd() {
                squares.forEach(square => square.classList.remove('dragging'));
            }

            // Manejo de eventos táctiles
            function handleTouchStart(e) {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    touchStartIdLocal = parseInt(this.id);
                }
            }

            function handleTouchEnd(e) {
                if (touchStartX === null || touchStartY === null) return;
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const threshold = 30;
                let dragEndIndexLocal = touchStartIdLocal;
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > threshold) {
                        dragEndIndexLocal = touchStartIdLocal + 1;
                    } else if (deltaX < -threshold) {
                        dragEndIndexLocal = touchStartIdLocal - 1;
                    }
                } else {
                    if (deltaY > threshold) {
                        dragEndIndexLocal = touchStartIdLocal + width;
                    } else if (deltaY < -threshold) {
                        dragEndIndexLocal = touchStartIdLocal - width;
                    }
                }
                if (isAdjacent(touchStartIdLocal, dragEndIndexLocal) && dragEndIndexLocal >= 0 && dragEndIndexLocal < width * width) {
                    swapEmojis(touchStartIdLocal, dragEndIndexLocal);
                    if (findMatchesUserAction().length > 0) {
                        checkMatches(true);
                    } else {
                        swapEmojis(dragEndIndexLocal, touchStartIdLocal);
                    }
                }
                touchStartX = null;
                touchStartY = null;
                touchStartIdLocal = null;
            }

            // Manejar clic en una celda (para activar power-ups)
            function handleSquareClick(e) {
                const index = parseInt(this.id);
                if (powerUpActive && index === blinkingIndex && emojis[index] === bombEmoji) {
                    triggerPowerUp(index);
                }
            }

            // Verificar si dos índices son adyacentes
            function isAdjacent(index1, index2) {
                const row1 = Math.floor(index1 / width);
                const col1 = index1 % width;
                const row2 = Math.floor(index2 / width);
                const col2 = index2 % width;
                const rowDiff = Math.abs(row1 - row2);
                const colDiff = Math.abs(col1 - col2);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            // Intercambiar emojis entre dos índices
            function swapEmojis(index1, index2) {
                const tempEmoji = emojis[index1];
                emojis[index1] = emojis[index2];
                emojis[index2] = tempEmoji;
                setSquareContent(squares[index1], emojis[index1]);
                setSquareContent(squares[index2], emojis[index2]);
                squares[index1].style.setProperty('--bg-color', emojiColors[emojis[index1]]);
                squares[index2].style.setProperty('--bg-color', emojiColors[emojis[index2]]);

                updatePowerUpPosition(index1, index2);
            }

            // Actualizar la posición del power-up si está activo
            function updatePowerUpPosition(oldIndex, newIndex) {
                if (powerUpActive) {
                    if (oldIndex === blinkingIndex) {
                        squares[blinkingIndex].classList.remove('blinking');
                        blinkingIndex = newIndex;
                        squares[blinkingIndex].classList.add('blinking');
                    } else if (newIndex === blinkingIndex) {
                        squares[blinkingIndex].classList.remove('blinking');
                        blinkingIndex = oldIndex;
                        squares[blinkingIndex].classList.add('blinking');
                    }
                }
            }

            // Encontrar todos los matches en la cuadrícula
            function findAllMatches() {
                const matches = [];
                // Horizontal Matches
                for (let row = 0; row < width; row++) {
                    for (let col = 0; col < width - 2; col++) {
                        const idx = row * width + col;
                        const first = emojis[idx];
                        const second = emojis[idx + 1];
                        const third = emojis[idx + 2];
                        if (first === second && second === third && first !== '' && first !== bombEmoji) {
                            let match = [idx, idx + 1, idx + 2];
                            // Evitar matches que incluyan el power-up
                            if (match.some(index => emojis[index] === bombEmoji)) continue;
                            // Extender el match si hay más emojis iguales
                            for (let k = col + 3; k < width; k++) {
                                const nextIdx = row * width + k;
                                if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                                    match.push(nextIdx);
                                } else {
                                    break;
                                }
                            }
                            matches.push(match);
                            col += match.length - 1;
                        }
                    }
                }
                // Vertical Matches
                for (let col = 0; col < width; col++) {
                    for (let row = 0; row < width - 2; row++) {
                        const idx = row * width + col;
                        const first = emojis[idx];
                        const second = emojis[idx + width];
                        const third = emojis[idx + 2 * width];
                        if (first === second && second === third && first !== '' && first !== bombEmoji) {
                            let match = [idx, idx + width, idx + 2 * width];
                            // Evitar matches que incluyan el power-up
                            if (match.some(index => emojis[index] === bombEmoji)) continue;
                            // Extender el match si hay más emojis iguales
                            for (let k = row + 3; k < width; k++) {
                                const nextIdx = k * width + col;
                                if (emojis[nextIdx] === first && emojis[nextIdx] !== bombEmoji) {
                                    match.push(nextIdx);
                                } else {
                                    break;
                                }
                            }
                            matches.push(match);
                            row += match.length - 1;
                        }
                    }
                }
                return matches;
            }

            // Encontrar matches como resultado de una acción del usuario
            function findMatchesUserAction() {
                return findAllMatches();
            }

            // Verificar y procesar matches
            function checkMatches(isUserAction = false) {
                let matches = findAllMatches();
                if (matches.length === 0) {
                    // Opcional: verificar si el juego ha terminado
                    checkEndGame();
                    return;
                }
                destroyedEmojisCount += matches.reduce((sum, match) => sum + match.length, 0);
                if (isUserAction) {
                    matches.forEach(match => {
                        let matchLength = match.length;
                        let matchPoints = 1;
                        if (matchLength === 4) {
                            matchPoints = 2;
                        } else if (matchLength >= 5) {
                            matchPoints = 3;
                        }
                        matchesMade += matchPoints;
                        matchesDisplay.textContent = matchesMade;
                        createScorePopup(match[0], `+${matchPoints}`);
                    });
                    updateHighScore();

                    // Verificar si se ha alcanzado el objetivo de matches para subir de nivel
                    if (matchesMade >= targetMatches) {
                        levelUp();
                    }
                }
                matches.forEach(match => {
                    match.forEach(index => {
                        let emoji = emojis[index];
                        destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                        emojis[index] = '';
                        clearSquareContent(squares[index]);
                        squares[index].style.removeProperty('--bg-color');

                        // Manejar la eliminación del power-up si está en este índice
                        if (powerUpActive && index === blinkingIndex) {
                            squares[index].classList.remove('blinking');
                            powerUpActive = false;
                            blinkingIndex = null;
                        }
                    });
                });
                checkPowerup();
                setTimeout(() => {
                    fillEmptySpaces();
                }, 500);
            }

            // Rellenar espacios vacíos después de eliminar matches
            function fillEmptySpaces() {
                for (let col = 0; col < width; col++) {
                    let emptySpots = 0;
                    for (let row = width - 1; row >= 0; row--) {
                        const idx = row * width + col;
                        if (emojis[idx] === '' || emojis[idx] === undefined) {
                            emptySpots++;
                        } else if (emptySpots > 0) {
                            const newIdx = (row + emptySpots) * width + col;
                            const movingEmoji = emojis[idx];
                            emojis[newIdx] = movingEmoji;
                            setSquareContent(squares[newIdx], movingEmoji);
                            squares[newIdx].style.setProperty('--bg-color', emojiColors[movingEmoji]);
                            emojis[idx] = '';
                            clearSquareContent(squares[idx]);
                            squares[idx].style.removeProperty('--bg-color');
                            squares[newIdx].classList.add('fall');
                            setTimeout(() => {
                                squares[newIdx].classList.remove('fall');
                            }, 300);

                            // Actualizar la posición del power-up si es necesario
                            if (powerUpActive && movingEmoji === bombEmoji) {
                                squares[blinkingIndex].classList.remove('blinking');
                                blinkingIndex = newIdx;
                                squares[blinkingIndex].classList.add('blinking');
                            }
                        }
                    }

                    // Insertar nuevos emojis en los espacios vacíos en la parte superior
                    for (let row = 0; row < emptySpots; row++) {
                        const idx = row * width + col;
                        const newEmoji = getRandomEmoji();
                        emojis[idx] = newEmoji;
                        setSquareContent(squares[idx], newEmoji);
                        squares[idx].style.setProperty('--bg-color', emojiColors[newEmoji]);
                        squares[idx].classList.add('fall');
                        setTimeout(() => {
                            squares[idx].classList.remove('fall');
                        }, 300);

                        // Actualizar la posición del power-up si es necesario
                        if (powerUpActive && newEmoji === bombEmoji) {
                            if (blinkingIndex !== idx) {
                                if (blinkingIndex !== null) {
                                    squares[blinkingIndex].classList.remove('blinking');
                                }
                                blinkingIndex = idx;
                                squares[blinkingIndex].classList.add('blinking');
                            }
                        }
                    }
                }

                // Después de rellenar, verificar si hay nuevos matches
                setTimeout(() => {
                    checkMatches();
                }, 500);
            }

            // Verificar si se puede activar un power-up
            function checkPowerup() {
                if (destroyedEmojisCount >= 10 && !powerUpActive) {
                    activatePowerup();
                }
            }

            // Activar un power-up (bomba)
            function activatePowerup() {
                const availableIndices = [];
                for (let i = 0; i < width * width; i++) {
                    if (emojis[i] !== '' && emojis[i] !== bombEmoji) {
                        availableIndices.push(i);
                    }
                }
                if (availableIndices.length === 0) return;
                blinkingIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                emojis[blinkingIndex] = bombEmoji;
                setSquareContent(squares[blinkingIndex], bombEmoji);
                squares[blinkingIndex].style.setProperty('--bg-color', emojiColors[bombEmoji]);
                squares[blinkingIndex].classList.add('blinking');
                powerUpActive = true;
                destroyedEmojisCount = 0;
            }

            // Disparar el power-up (bomba) cuando se hace clic en ella
            function triggerPowerUp(index) {
                const row = Math.floor(index / width);
                const col = index % width;
                const indicesToDestroy = [];
                // Destruir en rango horizontal
                for (let c = col - 2; c <= col + 2; c++) {
                    if (c >= 0 && c < width) {
                        const idx = row * width + c;
                        if (emojis[idx] !== '') {
                            indicesToDestroy.push(idx);
                        }
                    }
                }
                // Destruir en rango vertical
                for (let r = row - 2; r <= row + 2; r++) {
                    if (r >= 0 && r < width) {
                        const idx = r * width + col;
                        if (emojis[idx] !== '') {
                            indicesToDestroy.push(idx);
                        }
                    }
                }
                const uniqueIndices = [...new Set(indicesToDestroy)];
                gameContainer.classList.add('vibrate');
                setTimeout(() => {
                    gameContainer.classList.remove('vibrate');
                }, 500);
                uniqueIndices.forEach(idx => {
                    setTimeout(() => {
                        let emoji = emojis[idx];
                        destroyedEmojis[emoji] = (destroyedEmojis[emoji] || 0) + 1;
                        emojis[idx] = '';
                        clearSquareContent(squares[idx]);
                        squares[idx].style.removeProperty('--bg-color');
                    }, 0);
                });
                powerUpActive = false;
                squares[index].classList.remove('blinking');
                blinkingIndex = null;
                setTimeout(() => {
                    fillEmptySpaces();
                }, 500);
            }

            // Crear partículas de animación (opcional)
            function createParticles(count, color, x, y) {
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    particle.style.backgroundColor = color;
                    const rect = grid.getBoundingClientRect();
                    particle.style.left = `${x - rect.left + 27.5}px`;
                    particle.style.top = `${y - rect.top + 27.5}px`;
                    particle.style.setProperty('--tx', `${Math.random() * 100 - 50}px`);
                    particle.style.setProperty('--ty', `${Math.random() * 100 - 50}px`);
                    particlesContainer.appendChild(particle);
                    setTimeout(() => {
                        particle.remove();
                    }, 1000);
                }
            }

            // Crear un popup de puntuación al hacer un match
            function createScorePopup(index, text) {
                const popup = document.createElement('div');
                popup.classList.add('score-popup');
                const rect = squares[index].getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                const left = rect.left - gameRect.left + rect.width / 2 - 10;
                const top = rect.top - gameRect.top + rect.height / 2 - 10;
                popup.style.left = `${left}px`;
                popup.style.top = `${top}px`;
                popup.textContent = text;
                popup.style.zIndex = '10';
                gameContainer.appendChild(popup);
                setTimeout(() => {
                    popup.remove();
                }, 1000);
            }

            // Verificar si es hora de subir de nivel
            function checkLevelUp() {
                if (matchesMade >= targetMatches) {
                    levelUp();
                }
            }

            // Subir de nivel y actualizar la lista de emojis
            function levelUp() {
                level += 1;
                levelDisplay.textContent = level;
                targetMatches += 5;
                targetMatchesDisplay.textContent = targetMatches;
                setCurrentEmojis();
                matchesMade = 0; // Resetear contador de matches al subir de nivel
                matchesDisplay.textContent = matchesMade;
                fillBoard(); // Rellenar el tablero para incluir nuevos emojis
            }

            // Reiniciar el juego
            function resetGame() {
                totalGamesPlayed += 1;
                totalTimePlayed += Date.now() - gameStartTime;
                saveStatistics();
                matchesMade = 0;
                targetMatches = 5;
                level = 1;
                destroyedEmojisCount = 0;
                powerUpActive = false;
                blinkingIndex = null;
                matchesDisplay.textContent = matchesMade;
                targetMatchesDisplay.textContent = targetMatches;
                levelDisplay.textContent = level;
                gameOverDisplay.style.display = 'none';
                squares.forEach(square => {
                    square.classList.remove('blinking', 'match', 'fall', 'hint');
                    emojis[square.id] = '';
                    clearSquareContent(square);
                    square.style.removeProperty('--bg-color');
                });
                currentEmojis = [];
                setCurrentEmojis();
                gameStartTime = Date.now();
                fillBoard();
                // No volver a añadir event listeners aquí para evitar duplicados
            }

            // Mostrar información y estadísticas del juego
            function showInfo() {
                // Verificar si ya existe un popup para evitar duplicados
                if (document.querySelector('.stats-popup')) return;

                const infoContainer = document.createElement('div');
                infoContainer.classList.add('stats-popup');

                const title = document.createElement('h2');
                title.textContent = 'Estadísticas';
                infoContainer.appendChild(title);

                const gamesPlayed = document.createElement('p');
                gamesPlayed.textContent = `Partidas jugadas: ${totalGamesPlayed}`;
                infoContainer.appendChild(gamesPlayed);

                const timePlayed = document.createElement('p');
                const totalMinutes = Math.floor(totalTimePlayed / 60000);
                timePlayed.textContent = `Tiempo total jugado: ${totalMinutes} minutos`;
                infoContainer.appendChild(timePlayed);

                const emojiStatsTitle = document.createElement('h3');
                emojiStatsTitle.textContent = 'Top 10 emojis destruidos:';
                infoContainer.appendChild(emojiStatsTitle);

                const sortedEmojis = Object.entries(destroyedEmojis).sort((a, b) => b[1] - a[1]).slice(0, 10);
                const emojiList = document.createElement('ul');
                sortedEmojis.forEach(([emoji, count]) => {
                    const listItem = document.createElement('li');
                    if (emoji === dogEmoji) {
                        listItem.innerHTML = `<img src="Dog.png" alt="Dog" style="width: 20px; height: 20px; vertical-align: middle;"> - ${count}`;
                    } else {
                        listItem.textContent = `${emoji} - ${count}`;
                    }
                    emojiList.appendChild(listItem);
                });
                infoContainer.appendChild(emojiList);

                const closeButton = document.createElement('button');
                closeButton.textContent = 'Cerrar';
                closeButton.addEventListener('click', () => {
                    infoContainer.remove();
                });
                infoContainer.appendChild(closeButton);

                document.body.appendChild(infoContainer);
            }

            // Resetear el temporizador de inactividad
            function resetIdleTimer() {
                lastUserActionTime = Date.now();
            }

            // Mostrar una pista de posibles movimientos
            function hintPossibleMatch() {
                const possibleMoves = findPossibleMoves();
                if (possibleMoves.length > 0) {
                    const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    randomMove.forEach(index => {
                        squares[index].classList.add('hint');
                        setTimeout(() => {
                            squares[index].classList.remove('hint');
                        }, 1000);
                    });
                }
            }

            // Mostrar una pista después de 6 segundos de inactividad
            setInterval(() => {
                if (Date.now() - lastUserActionTime >= 6000) {
                    hintPossibleMatch();
                }
            }, 1000);

            // Verificar si el juego ha terminado
            function checkEndGame() {
                const possibleMoves = findPossibleMoves();
                if (possibleMoves.length === 0) {
                    gameOverDisplay.style.display = 'block';
                    squares.forEach(square => {
                        square.removeEventListener('dragstart', dragStart);
                        square.removeEventListener('dragover', dragOver);
                        square.removeEventListener('drop', dragDrop);
                        square.removeEventListener('dragend', dragEnd);
                        square.removeEventListener('click', handleSquareClick);
                        square.removeEventListener('touchstart', handleTouchStart);
                        square.removeEventListener('touchend', handleTouchEnd);
                    });
                }
            }

            // Encontrar posibles movimientos que crean matches
            function findPossibleMoves() {
                let possibleMoves = [];
                for (let i = 0; i < width * width; i++) {
                    const row = Math.floor(i / width);
                    const col = i % width;
                    if (col < width - 1) {
                        swapEmojis(i, i + 1);
                        if (findAllMatches().length > 0) {
                            possibleMoves.push([i, i + 1]);
                        }
                        swapEmojis(i, i + 1);
                    }
                    if (row < width - 1) {
                        swapEmojis(i, i + width);
                        if (findAllMatches().length > 0) {
                            possibleMoves.push([i, i + width]);
                        }
                        swapEmojis(i, i + width);
                    }
                }
                return possibleMoves;
            }

            // Inicializar el juego al cargar la página
            initializeGame();

            // Explicación de la Aparición de Nuevos Emojis
            /*
                La mecánica de generación de nuevos emojis está manejada principalmente por la función `fillEmptySpaces()`. 
                Aquí está cómo funciona:

                1. **Detección de Espacios Vacíos**:
                    - Después de que se detectan y eliminan los emojis que forman un match, algunos espacios en la cuadrícula quedan vacíos.
                    - La función `fillEmptySpaces()` recorre cada columna de la cuadrícula.

                2. **Caída de Emojis Existentes**:
                    - Para cada columna, cuenta cuántos espacios vacíos (`emptySpots`) hay.
                    - Luego, recorre la columna desde abajo hacia arriba. Si encuentra un emoji que no está vacío y hay espacios vacíos debajo, mueve ese emoji hacia abajo tantas posiciones como espacios vacíos existan.
                    - Aplica una clase CSS `.fall` para animar la caída del emoji hacia su nueva posición.

                3. **Inserción de Nuevos Emojis**:
                    - Después de mover los emojis existentes hacia abajo, hay que llenar los espacios vacíos en la parte superior de la columna.
                    - Para cada espacio vacío en la parte superior, genera un nuevo emoji aleatorio de la lista `currentEmojis`.
                    - Asigna este nuevo emoji a la celda vacía correspondiente y aplica la clase `.fall` para animar su aparición desde la parte superior hacia abajo.

                4. **Manejo del Power-Up durante la Caída**:
                    - Si el emoji que se está moviendo es un power-up (bombEmoji), la función actualiza la variable `blinkingIndex` para reflejar su nueva posición.
                    - Esto asegura que el power-up mantenga su funcionalidad y animación de parpadeo correctamente.

                5. **Actualización y Verificación Continua**:
                    - Una vez que los nuevos emojis se han insertado y las animaciones han finalizado, la función `checkMatches()` se llama nuevamente para detectar si hay nuevos matches formados por los emojis recién insertados.
                    - Esto permite que el juego continúe de manera fluida, generando y desplazando nuevos emojis según el progreso del jugador.

                **Resumen**:
                La clave está en mover los emojis existentes hacia abajo para llenar los espacios vacíos y luego insertar nuevos emojis en la parte superior de cada columna, permitiendo que caigan naturalmente al llenar los huecos. Esta mecánica evita la sustitución masiva de emojis y mantiene la dinámica del juego fluida y visualmente atractiva.
            */
        });
    </script>
</body>
</html>